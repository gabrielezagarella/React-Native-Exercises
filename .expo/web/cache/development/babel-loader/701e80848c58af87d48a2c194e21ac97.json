{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport invariant from 'invariant';\nexport var CellRenderMask = function () {\n  function CellRenderMask(numCells) {\n    _classCallCheck(this, CellRenderMask);\n\n    invariant(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [{\n        first: 0,\n        last: numCells - 1,\n        isSpacer: true\n      }];\n    }\n  }\n\n  _createClass(CellRenderMask, [{\n    key: \"enumerateRegions\",\n    value: function enumerateRegions() {\n      return this._regions;\n    }\n  }, {\n    key: \"addCells\",\n    value: function addCells(cells) {\n      var _this$_regions;\n\n      invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');\n\n      if (cells.last < cells.first) {\n        return;\n      }\n\n      var _this$_findRegion = this._findRegion(cells.first),\n          _this$_findRegion2 = _slicedToArray(_this$_findRegion, 2),\n          firstIntersect = _this$_findRegion2[0],\n          firstIntersectIdx = _this$_findRegion2[1];\n\n      var _this$_findRegion3 = this._findRegion(cells.last),\n          _this$_findRegion4 = _slicedToArray(_this$_findRegion3, 2),\n          lastIntersect = _this$_findRegion4[0],\n          lastIntersectIdx = _this$_findRegion4[1];\n\n      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n        return;\n      }\n\n      var newLeadRegion = [];\n      var newTailRegion = [];\n\n      var newMainRegion = _objectSpread(_objectSpread({}, cells), {}, {\n        isSpacer: false\n      });\n\n      if (firstIntersect.first < newMainRegion.first) {\n        if (firstIntersect.isSpacer) {\n          newLeadRegion.push({\n            first: firstIntersect.first,\n            last: newMainRegion.first - 1,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.first = firstIntersect.first;\n        }\n      }\n\n      if (lastIntersect.last > newMainRegion.last) {\n        if (lastIntersect.isSpacer) {\n          newTailRegion.push({\n            first: newMainRegion.last + 1,\n            last: lastIntersect.last,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.last = lastIntersect.last;\n        }\n      }\n\n      var replacementRegions = [].concat(newLeadRegion, [newMainRegion], newTailRegion);\n      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n\n      (_this$_regions = this._regions).splice.apply(_this$_regions, [firstIntersectIdx, numRegionsToDelete].concat(_toConsumableArray(replacementRegions)));\n    }\n  }, {\n    key: \"numCells\",\n    value: function numCells() {\n      return this._numCells;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function (region, i) {\n        return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;\n      });\n    }\n  }, {\n    key: \"_findRegion\",\n    value: function _findRegion(cellIdx) {\n      var firstIdx = 0;\n      var lastIdx = this._regions.length - 1;\n\n      while (firstIdx <= lastIdx) {\n        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var middleRegion = this._regions[middleIdx];\n\n        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n          return [middleRegion, middleIdx];\n        } else if (cellIdx < middleRegion.first) {\n          lastIdx = middleIdx - 1;\n        } else if (cellIdx > middleRegion.last) {\n          firstIdx = middleIdx + 1;\n        }\n      }\n\n      invariant(false, \"A region was not found containing cellIdx \" + cellIdx);\n    }\n  }]);\n\n  return CellRenderMask;\n}();","map":{"version":3,"names":["invariant","CellRenderMask","numCells","_numCells","_regions","first","last","isSpacer","cells","_findRegion","firstIntersect","firstIntersectIdx","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","push","replacementRegions","numRegionsToDelete","splice","other","length","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/Lists/CellRenderMask.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}