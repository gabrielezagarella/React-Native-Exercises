{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n'use strict';\n\nimport parseErrorStack from \"../../Core/Devtools/parseErrorStack\";\nimport NativeLogBox from \"../../NativeModules/specs/NativeLogBox\";\nimport LogBoxLog from \"./LogBoxLog\";\nimport { parseLogBoxException } from \"./parseLogBoxLog\";\nimport * as React from 'react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar observers = new Set();\nvar ignorePatterns = new Set();\nvar appInfo = null;\nvar logs = new Set();\nvar updateTimeout = null;\nvar _isDisabled = false;\n\nvar _selectedIndex = -1;\n\nvar warningFilter = function warningFilter(format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1\n  };\n};\n\nvar LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs: logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\n\nexport function reportLogBoxError(error, componentStack) {\n  var ExceptionsManager = require(\"../../Core/ExceptionsManager\");\n\n  error.message = LOGBOX_ERROR_MESSAGE + \"\\n\\n\" + error.message;\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n\n  ExceptionsManager.handleException(error, true);\n}\nexport function isLogBoxErrorMessage(message) {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\nexport function isMessageIgnored(message) {\n  for (var _iterator = _createForOfIteratorHelperLoose(ignorePatterns), _step; !(_step = _iterator()).done;) {\n    var pattern = _step.value;\n\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(function () {\n      updateTimeout = null;\n      var nextState = getNextState();\n      observers.forEach(function (_ref) {\n        var observer = _ref.observer;\n        return observer(nextState);\n      });\n    });\n  }\n}\n\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  var lastLog = Array.from(logs).pop();\n\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    var OPTIMISTIC_WAIT_TIME = 1000;\n\n    var _addPendingLog = function addPendingLog() {\n      logs.add(newLog);\n\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n\n      _addPendingLog = null;\n    };\n\n    var optimisticTimeout = setTimeout(function () {\n      if (_addPendingLog) {\n        _addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate(function (status) {\n      if (_addPendingLog && status !== 'PENDING') {\n        _addPendingLog();\n\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log) {\n  var errorForStackTrace = new Error();\n  setImmediate(function () {\n    try {\n      var stack = parseErrorStack(errorForStackTrace == null ? void 0 : errorForStackTrace.stack);\n      appendNewLog(new LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack: stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\nexport function addException(error) {\n  setImmediate(function () {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\nexport function symbolicateLogNow(log) {\n  log.symbolicate(function () {\n    handleUpdate();\n  });\n}\nexport function retrySymbolicateLogNow(log) {\n  log.retrySymbolicate(function () {\n    handleUpdate();\n  });\n}\nexport function symbolicateLogLazy(log) {\n  log.symbolicate();\n}\nexport function clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\nexport function setSelectedLog(proposedNewIndex) {\n  var oldIndex = _selectedIndex;\n  var newIndex = proposedNewIndex;\n  var logArray = Array.from(logs);\n  var index = logArray.length - 1;\n\n  while (index >= 0) {\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n\n    index -= 1;\n  }\n\n  _selectedIndex = newIndex;\n  handleUpdate();\n\n  if (NativeLogBox) {\n    setTimeout(function () {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\nexport function clearWarnings() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== 'warn';\n  });\n\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\nexport function clearErrors() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== 'error' && log.level !== 'fatal';\n  });\n\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\nexport function dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\nexport function setWarningFilter(filter) {\n  warningFilter = filter;\n}\nexport function setAppInfo(info) {\n  appInfo = info;\n}\nexport function getAppInfo() {\n  return appInfo != null ? appInfo() : null;\n}\nexport function checkWarningFilter(format) {\n  return warningFilter(format);\n}\nexport function getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\nexport function addIgnorePatterns(patterns) {\n  var existingSize = ignorePatterns.size;\n  patterns.forEach(function (pattern) {\n    if (pattern instanceof RegExp) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(ignorePatterns), _step2; !(_step2 = _iterator2()).done;) {\n        var existingPattern = _step2.value;\n\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n\n      ignorePatterns.add(pattern);\n    }\n\n    ignorePatterns.add(pattern);\n  });\n\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n\n  logs = new Set(Array.from(logs).filter(function (log) {\n    return !isMessageIgnored(log.message.content);\n  }));\n  handleUpdate();\n}\nexport function setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n\n  _isDisabled = value;\n  handleUpdate();\n}\nexport function isDisabled() {\n  return _isDisabled;\n}\nexport function observe(observer) {\n  var subscription = {\n    observer: observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe: function unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\nexport function withSubscription(WrappedComponent) {\n  var LogBoxStateSubscription = function (_React$Component) {\n    _inherits(LogBoxStateSubscription, _React$Component);\n\n    var _super = _createSuper(LogBoxStateSubscription);\n\n    function LogBoxStateSubscription() {\n      var _this;\n\n      _classCallCheck(this, LogBoxStateSubscription);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.state = {\n        logs: new Set(),\n        isDisabled: false,\n        hasError: false,\n        selectedLogIndex: -1\n      };\n\n      _this._handleDismiss = function () {\n        var _this$state = _this.state,\n            selectedLogIndex = _this$state.selectedLogIndex,\n            stateLogs = _this$state.logs;\n        var logsArray = Array.from(stateLogs);\n\n        if (selectedLogIndex != null) {\n          if (logsArray.length - 1 <= 0) {\n            setSelectedLog(-1);\n          } else if (selectedLogIndex >= logsArray.length - 1) {\n            setSelectedLog(selectedLogIndex - 1);\n          }\n\n          dismiss(logsArray[selectedLogIndex]);\n        }\n      };\n\n      _this._handleMinimize = function () {\n        setSelectedLog(-1);\n      };\n\n      _this._handleSetSelectedLog = function (index) {\n        setSelectedLog(index);\n      };\n\n      return _this;\n    }\n\n    _createClass(LogBoxStateSubscription, [{\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(err, errorInfo) {\n        reportLogBoxError(err, errorInfo.componentStack);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (this.state.hasError) {\n          return null;\n        }\n\n        return _jsx(WrappedComponent, {\n          logs: Array.from(this.state.logs),\n          isDisabled: this.state.isDisabled,\n          selectedLogIndex: this.state.selectedLogIndex\n        });\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        this._subscription = observe(function (data) {\n          _this2.setState(data);\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        if (this._subscription != null) {\n          this._subscription.unsubscribe();\n        }\n      }\n    }], [{\n      key: \"getDerivedStateFromError\",\n      value: function getDerivedStateFromError() {\n        return {\n          hasError: true\n        };\n      }\n    }]);\n\n    return LogBoxStateSubscription;\n  }(React.Component);\n\n  return LogBoxStateSubscription;\n}","map":{"version":3,"names":["parseErrorStack","NativeLogBox","LogBoxLog","parseLogBoxException","React","observers","Set","ignorePatterns","appInfo","logs","updateTimeout","_isDisabled","_selectedIndex","warningFilter","format","finalFormat","forceDialogImmediately","suppressDialog_LEGACY","suppressCompletely","monitorEvent","monitorListVersion","monitorSampleRate","LOGBOX_ERROR_MESSAGE","getNextState","isDisabled","selectedLogIndex","reportLogBoxError","error","componentStack","ExceptionsManager","require","message","handleException","isLogBoxErrorMessage","includes","isMessageIgnored","pattern","RegExp","test","handleUpdate","setImmediate","nextState","forEach","observer","appendNewLog","newLog","content","lastLog","Array","from","pop","category","incrementCount","level","OPTIMISTIC_WAIT_TIME","addPendingLog","add","setSelectedLog","size","optimisticTimeout","setTimeout","symbolicate","status","clearTimeout","addLog","log","errorForStackTrace","Error","stack","isComponentError","addException","loggingError","symbolicateLogNow","retrySymbolicateLogNow","retrySymbolicate","symbolicateLogLazy","clear","proposedNewIndex","oldIndex","newIndex","logArray","index","length","show","hide","clearWarnings","newLogs","filter","clearErrors","dismiss","has","delete","setWarningFilter","setAppInfo","info","getAppInfo","checkWarningFilter","getIgnorePatterns","addIgnorePatterns","patterns","existingSize","existingPattern","toString","setDisabled","value","observe","subscription","unsubscribe","withSubscription","WrappedComponent","LogBoxStateSubscription","state","hasError","_handleDismiss","stateLogs","logsArray","_handleMinimize","_handleSetSelectedLog","err","errorInfo","_subscription","data","setState","Component"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\n('use strict');\n\nimport type {ExtendedError} from '../../Core/ExtendedError';\nimport type {LogLevel} from './LogBoxLog';\nimport type {\n  Category,\n  ComponentStack,\n  ExtendedExceptionData,\n  Message,\n} from './parseLogBoxLog';\n\nimport parseErrorStack from '../../Core/Devtools/parseErrorStack';\nimport NativeLogBox from '../../NativeModules/specs/NativeLogBox';\nimport LogBoxLog from './LogBoxLog';\nimport {parseLogBoxException} from './parseLogBoxLog';\nimport * as React from 'react';\nexport type LogBoxLogs = Set<LogBoxLog>;\nexport type LogData = $ReadOnly<{|\n  level: LogLevel,\n  message: Message,\n  category: Category,\n  componentStack: ComponentStack,\n|}>;\n\nexport type Observer = (\n  $ReadOnly<{|\n    logs: LogBoxLogs,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = $ReadOnly<{|\n  unsubscribe: () => void,\n|}>;\n\nexport type WarningInfo = {|\n  finalFormat: string,\n  forceDialogImmediately: boolean,\n  suppressDialog_LEGACY: boolean,\n  suppressCompletely: boolean,\n  monitorEvent: string | null,\n  monitorListVersion: number,\n  monitorSampleRate: number,\n|};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype AppInfo = $ReadOnly<{|\n  appVersion: string,\n  engine: string,\n  onPress?: ?() => void,\n|}>;\n\nconst observers: Set<{observer: Observer, ...}> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet appInfo: ?() => AppInfo = null;\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout: $FlowFixMe | null = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nlet warningFilter: WarningFilter = function (format) {\n  return {\n    finalFormat: format,\n    forceDialogImmediately: false,\n    suppressDialog_LEGACY: true,\n    suppressCompletely: false,\n    monitorEvent: 'unknown',\n    monitorListVersion: 0,\n    monitorSampleRate: 1,\n  };\n};\n\nconst LOGBOX_ERROR_MESSAGE =\n  'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(\n  error: ExtendedError,\n  componentStack?: string,\n): void {\n  const ExceptionsManager = require('../../Core/ExceptionsManager');\n\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error, /* isFatal */ true);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === 'string' && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediate(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({observer}) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog) {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // sybolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: ?() => void = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    newLog.symbolicate(status => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        }),\n      );\n    } catch (error) {\n      reportLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(log: LogBoxLog) {\n  log.symbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(log: LogBoxLog) {\n  log.retrySymbolicate(() => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(log: LogBoxLog) {\n  log.symbolicate();\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter(log => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter(\n    log => log.level !== 'error' && log.level !== 'fatal',\n  );\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function setWarningFilter(filter: WarningFilter): void {\n  warningFilter = filter;\n}\n\nexport function setAppInfo(info: () => AppInfo): void {\n  appInfo = info;\n}\n\nexport function getAppInfo(): ?AppInfo {\n  return appInfo != null ? appInfo() : null;\n}\n\nexport function checkWarningFilter(format: string): WarningInfo {\n  return warningFilter(format);\n}\n\nexport function getIgnorePatterns(): $ReadOnlyArray<IgnorePattern> {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(\n  patterns: $ReadOnlyArray<IgnorePattern>,\n): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(\n    Array.from(logs).filter(log => !isMessageIgnored(log.message.content)),\n  );\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = {observer};\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\ntype Props = $ReadOnly<{||}>;\ntype State = $ReadOnly<{|\n  logs: LogBoxLogs,\n  isDisabled: boolean,\n  hasError: boolean,\n  selectedLogIndex: number,\n|}>;\n\ntype SubscribedComponent = React.AbstractComponent<\n  $ReadOnly<{|\n    logs: $ReadOnlyArray<LogBoxLog>,\n    isDisabled: boolean,\n    selectedLogIndex: number,\n  |}>,\n>;\n\nexport function withSubscription(\n  WrappedComponent: SubscribedComponent,\n): React.AbstractComponent<{||}> {\n  class LogBoxStateSubscription extends React.Component<Props, State> {\n    static getDerivedStateFromError(): {hasError: boolean} {\n      return {hasError: true};\n    }\n\n    componentDidCatch(err: Error, errorInfo: {componentStack: string, ...}) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription: ?Subscription;\n\n    state: State = {\n      logs: new Set(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render(): React.Node {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show anyback fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <WrappedComponent\n          logs={Array.from(this.state.logs)}\n          isDisabled={this.state.isDisabled}\n          selectedLogIndex={this.state.selectedLogIndex}\n        />\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe(data => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const {selectedLogIndex, logs: stateLogs} = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  return LogBoxStateSubscription;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}