{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport useRefEffect from \"../Utilities/useRefEffect\";\nimport { AnimatedEvent } from \"./AnimatedEvent\";\nimport NativeAnimatedHelper from \"./NativeAnimatedHelper\";\nimport AnimatedProps from \"./nodes/AnimatedProps\";\nimport { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef } from 'react';\nexport default function useAnimatedProps(props) {\n  var _useReducer = useReducer(function (count) {\n    return count + 1;\n  }, 0),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      scheduleUpdate = _useReducer2[1];\n\n  var onUpdateRef = useRef(null);\n  var node = useMemo(function () {\n    return new AnimatedProps(props, function () {\n      return onUpdateRef.current == null ? void 0 : onUpdateRef.current();\n    });\n  }, [props]);\n  useAnimatedPropsLifecycle(node);\n  var refEffect = useCallback(function (instance) {\n    node.setNativeView(instance);\n\n    onUpdateRef.current = function () {\n      if (process.env.NODE_ENV === 'test' || typeof instance !== 'object' || typeof (instance == null ? void 0 : instance.setNativeProps) !== 'function' || isFabricInstance(instance)) {\n        scheduleUpdate();\n      } else if (!node.__isNative) {\n        instance.setNativeProps(node.__getAnimatedValue());\n      } else {\n        throw new Error('Attempting to run JS driven animation on animated node ' + 'that has been moved to \"native\" earlier by starting an ' + 'animation with `useNativeDriver: true`');\n      }\n    };\n\n    var target = getEventTarget(instance);\n    var events = [];\n\n    for (var propName in props) {\n      var propValue = props[propName];\n\n      if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n\n        events.push([propName, propValue]);\n      }\n    }\n\n    return function () {\n      onUpdateRef.current = null;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(events), _step; !(_step = _iterator()).done;) {\n        var _ref = _step.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var _propName = _ref2[0];\n        var _propValue = _ref2[1];\n\n        _propValue.__detach(target, _propName);\n      }\n    };\n  }, [props, node]);\n  var callbackRef = useRefEffect(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\n\nfunction reduceAnimatedProps(node) {\n  return _objectSpread(_objectSpread({}, node.__getValue()), {}, {\n    collapsable: false\n  });\n}\n\nfunction useAnimatedPropsLifecycle(node) {\n  var prevNodeRef = useRef(null);\n  var isUnmountingRef = useRef(false);\n  useEffect(function () {\n    NativeAnimatedHelper.API.flushQueue();\n  });\n  useLayoutEffect(function () {\n    isUnmountingRef.current = false;\n    return function () {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  useLayoutEffect(function () {\n    node.__attach();\n\n    if (prevNodeRef.current != null) {\n      var prevNode = prevNodeRef.current;\n\n      prevNode.__restoreDefaultValues();\n\n      prevNode.__detach();\n\n      prevNodeRef.current = null;\n    }\n\n    return function () {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof (instance == null ? void 0 : instance.getScrollableNode) === 'function' ? instance.getScrollableNode() : instance;\n}\n\nfunction isFabricInstance(instance) {\n  var _instance$getScrollRe;\n\n  return hasFabricHandle(instance) || hasFabricHandle(instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()) || hasFabricHandle(instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef());\n}\n\nfunction hasFabricHandle(instance) {\n  var _instance$_internalIn, _instance$_internalIn2;\n\n  return (instance == null ? void 0 : (_instance$_internalIn = instance['_internalInstanceHandle']) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;\n}","map":{"version":3,"names":["useRefEffect","AnimatedEvent","NativeAnimatedHelper","AnimatedProps","useCallback","useEffect","useLayoutEffect","useMemo","useReducer","useRef","useAnimatedProps","props","count","scheduleUpdate","onUpdateRef","node","current","useAnimatedPropsLifecycle","refEffect","instance","setNativeView","process","env","NODE_ENV","setNativeProps","isFabricInstance","__isNative","__getAnimatedValue","Error","target","getEventTarget","events","propName","propValue","__attach","push","__detach","callbackRef","reduceAnimatedProps","__getValue","collapsable","prevNodeRef","isUnmountingRef","API","flushQueue","prevNode","__restoreDefaultValues","getScrollableNode","hasFabricHandle","getNativeScrollRef","getScrollResponder","stateNode","canonical"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/Animated/useAnimatedProps.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport useRefEffect from '../Utilities/useRefEffect';\nimport {AnimatedEvent} from './AnimatedEvent';\nimport NativeAnimatedHelper from './NativeAnimatedHelper';\nimport AnimatedProps from './nodes/AnimatedProps';\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react';\n\ntype ReducedProps<TProps> = {\n  ...TProps,\n  collapsable: boolean,\n  ...\n};\ntype CallbackRef<T> = T => mixed;\n\nexport default function useAnimatedProps<TProps: {...}, TInstance>(\n  props: TProps,\n): [ReducedProps<TProps>, CallbackRef<TInstance | null>] {\n  const [, scheduleUpdate] = useReducer<number, void>(count => count + 1, 0);\n  const onUpdateRef = useRef<?() => void>(null);\n\n  // TODO: Only invalidate `node` if animated props or `style` change. In the\n  // previous implementation, we permitted `style` to override props with the\n  // same name property name as styles, so we can probably continue doing that.\n  // The ordering of other props *should* not matter.\n  const node = useMemo(\n    () => new AnimatedProps(props, () => onUpdateRef.current?.()),\n    [props],\n  );\n  useAnimatedPropsLifecycle(node);\n\n  // TODO: This \"effect\" does three things:\n  //\n  //   1) Call `setNativeView`.\n  //   2) Update `onUpdateRef`.\n  //   3) Update listeners for `AnimatedEvent` props.\n  //\n  // Ideally, each of these would be separat \"effects\" so that they are not\n  // unnecessarily re-run when irrelevant dependencies change. For example, we\n  // should be able to hoist all `AnimatedEvent` props and only do #3 if either\n  // the `AnimatedEvent` props change or `instance` changes.\n  //\n  // But there is no way to transparently compose three separate callback refs,\n  // so we just combine them all into one for now.\n  const refEffect = useCallback(\n    (instance: TInstance) => {\n      // NOTE: This may be called more often than necessary (e.g. when `props`\n      // changes), but `setNativeView` already optimizes for that.\n      node.setNativeView(instance);\n\n      // NOTE: This callback is only used by the JavaScript animation driver.\n      onUpdateRef.current = () => {\n        if (\n          process.env.NODE_ENV === 'test' ||\n          typeof instance !== 'object' ||\n          typeof instance?.setNativeProps !== 'function' ||\n          isFabricInstance(instance)\n        ) {\n          // Schedule an update for this component to update `reducedProps`,\n          // but do not compute it immediately. If a parent also updated, we\n          // need to merge those new props in before updating.\n          scheduleUpdate();\n        } else if (!node.__isNative) {\n          // $FlowIgnore[not-a-function] - Assume it's still a function.\n          // $FlowFixMe[incompatible-use]\n          instance.setNativeProps(node.__getAnimatedValue());\n        } else {\n          throw new Error(\n            'Attempting to run JS driven animation on animated node ' +\n              'that has been moved to \"native\" earlier by starting an ' +\n              'animation with `useNativeDriver: true`',\n          );\n        }\n      };\n\n      const target = getEventTarget(instance);\n      const events = [];\n\n      for (const propName in props) {\n        const propValue = props[propName];\n        if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n          propValue.__attach(target, propName);\n          events.push([propName, propValue]);\n        }\n      }\n\n      return () => {\n        onUpdateRef.current = null;\n\n        for (const [propName, propValue] of events) {\n          propValue.__detach(target, propName);\n        }\n      };\n    },\n    [props, node],\n  );\n  const callbackRef = useRefEffect<TInstance>(refEffect);\n\n  return [reduceAnimatedProps<TProps>(node), callbackRef];\n}\n\nfunction reduceAnimatedProps<TProps>(\n  node: AnimatedProps,\n): ReducedProps<TProps> {\n  // Force `collapsable` to be false so that the native view is not flattened.\n  // Flattened views cannot be accurately referenced by the native driver.\n  return {\n    ...node.__getValue(),\n    collapsable: false,\n  };\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n */\nfunction useAnimatedPropsLifecycle(node: AnimatedProps): void {\n  const prevNodeRef = useRef<?AnimatedProps>(null);\n  const isUnmountingRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    // It is ok for multiple components to call `flushQueue` because it noops\n    // if the queue is empty. When multiple animated components are mounted at\n    // the same time. Only first component flushes the queue and the others will noop.\n    NativeAnimatedHelper.API.flushQueue();\n  });\n\n  useLayoutEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\nfunction getEventTarget<TInstance>(instance: TInstance): TInstance {\n  return typeof instance === 'object' &&\n    typeof instance?.getScrollableNode === 'function'\n    ? // $FlowFixMe[incompatible-use] - Legacy instance assumptions.\n      instance.getScrollableNode()\n    : instance;\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction isFabricInstance(instance: any): boolean {\n  return (\n    hasFabricHandle(instance) ||\n    // Some components have a setNativeProps function but aren't a host component\n    // such as lists like FlatList and SectionList. These should also use\n    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying\n    // host component. This crazy hack is essentially special casing those lists and\n    // ScrollView itself to use forceUpdate in Fabric.\n    // If these components end up using forwardRef then these hacks can go away\n    // as instance would actually be the underlying host component and the above check\n    // would be sufficient.\n    hasFabricHandle(instance?.getNativeScrollRef?.()) ||\n    hasFabricHandle(instance?.getScrollResponder?.()?.getNativeScrollRef?.())\n  );\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction hasFabricHandle(instance: any): boolean {\n  // eslint-disable-next-line dot-notation\n  return instance?.['_internalInstanceHandle']?.stateNode?.canonical != null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}