{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport RefreshControl from \"../Components/RefreshControl/RefreshControl\";\nimport ScrollView from \"../Components/ScrollView/ScrollView\";\nimport View from \"../Components/View/View\";\nimport Batchinator from \"../Interaction/Batchinator\";\nimport { findNodeHandle } from \"../ReactNative/RendererProxy\";\nimport flattenStyle from \"../StyleSheet/flattenStyle\";\nimport StyleSheet from \"../StyleSheet/StyleSheet\";\nimport clamp from \"../Utilities/clamp\";\nimport infoLog from \"../Utilities/infoLog\";\nimport { CellRenderMask } from \"./CellRenderMask\";\nimport ChildListCollection from \"./ChildListCollection\";\nimport FillRateHelper from \"./FillRateHelper\";\nimport StateSafePureComponent from \"./StateSafePureComponent\";\nimport ViewabilityHelper from \"./ViewabilityHelper\";\nimport CellRenderer from \"./VirtualizedListCellRenderer\";\nimport { VirtualizedListCellContextProvider, VirtualizedListContext, VirtualizedListContextProvider } from \"./VirtualizedListContext.js\";\nimport { computeWindowedRenderLimits, keyExtractor as defaultKeyExtractor } from \"./VirtualizeUtils\";\nimport invariant from 'invariant';\nimport * as React from 'react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar ON_END_REACHED_EPSILON = 0.001;\nvar _usedIndexForKey = false;\nvar _keylessItemComponentName = '';\n\nfunction horizontalOrDefault(horizontal) {\n  return horizontal != null ? horizontal : false;\n}\n\nfunction initialNumToRenderOrDefault(initialNumToRender) {\n  return initialNumToRender != null ? initialNumToRender : 10;\n}\n\nfunction maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {\n  return maxToRenderPerBatch != null ? maxToRenderPerBatch : 10;\n}\n\nfunction onEndReachedThresholdOrDefault(onEndReachedThreshold) {\n  return onEndReachedThreshold != null ? onEndReachedThreshold : 2;\n}\n\nfunction scrollEventThrottleOrDefault(scrollEventThrottle) {\n  return scrollEventThrottle != null ? scrollEventThrottle : 50;\n}\n\nfunction windowSizeOrDefault(windowSize) {\n  return windowSize != null ? windowSize : 21;\n}\n\nfunction findLastWhere(arr, predicate) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nvar VirtualizedList = function (_StateSafePureCompone) {\n  _inherits(VirtualizedList, _StateSafePureCompone);\n\n  var _super = _createSuper(VirtualizedList);\n\n  function VirtualizedList(_props) {\n    var _this$props$updateCel;\n\n    var _this;\n\n    _classCallCheck(this, VirtualizedList);\n\n    _this = _super.call(this, _props);\n\n    _this._getScrollMetrics = function () {\n      return _this._scrollMetrics;\n    };\n\n    _this._getOutermostParentListRef = function () {\n      if (_this._isNestedWithSameOrientation()) {\n        return _this.context.getOutermostParentListRef();\n      } else {\n        return _assertThisInitialized(_this);\n      }\n    };\n\n    _this._registerAsNestedChild = function (childList) {\n      _this._nestedChildLists.add(childList.ref, childList.cellKey);\n\n      if (_this._hasInteracted) {\n        childList.ref.recordInteraction();\n      }\n    };\n\n    _this._unregisterAsNestedChild = function (childList) {\n      _this._nestedChildLists.remove(childList.ref);\n    };\n\n    _this._onUpdateSeparators = function (keys, newProps) {\n      keys.forEach(function (key) {\n        var ref = key != null && _this._cellRefs[key];\n        ref && ref.updateSeparatorProps(newProps);\n      });\n    };\n\n    _this._getSpacerKey = function (isVertical) {\n      return isVertical ? 'height' : 'width';\n    };\n\n    _this._averageCellLength = 0;\n    _this._cellRefs = {};\n    _this._frames = {};\n    _this._footerLength = 0;\n    _this._hasTriggeredInitialScrollToIndex = false;\n    _this._hasInteracted = false;\n    _this._hasMore = false;\n    _this._hasWarned = {};\n    _this._headerLength = 0;\n    _this._hiPriInProgress = false;\n    _this._highestMeasuredFrameIndex = 0;\n    _this._indicesToKeys = new Map();\n    _this._lastFocusedCellKey = null;\n    _this._nestedChildLists = new ChildListCollection();\n    _this._offsetFromParentVirtualizedList = 0;\n    _this._prevParentOffset = 0;\n    _this._scrollMetrics = {\n      contentLength: 0,\n      dOffset: 0,\n      dt: 10,\n      offset: 0,\n      timestamp: 0,\n      velocity: 0,\n      visibleLength: 0,\n      zoomScale: 1\n    };\n    _this._scrollRef = null;\n    _this._sentEndForContentLength = 0;\n    _this._totalCellLength = 0;\n    _this._totalCellsMeasured = 0;\n    _this._viewabilityTuples = [];\n\n    _this._captureScrollRef = function (ref) {\n      _this._scrollRef = ref;\n    };\n\n    _this._defaultRenderScrollComponent = function (props) {\n      var onRefresh = props.onRefresh;\n\n      if (_this._isNestedWithSameOrientation()) {\n        return _jsx(View, _objectSpread({}, props));\n      } else if (onRefresh) {\n        var _props$refreshing;\n\n        invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) != null ? _props$refreshing : 'undefined') + '`');\n        return _jsx(ScrollView, _objectSpread(_objectSpread({}, props), {}, {\n          refreshControl: props.refreshControl == null ? _jsx(RefreshControl, {\n            refreshing: props.refreshing,\n            onRefresh: onRefresh,\n            progressViewOffset: props.progressViewOffset\n          }) : props.refreshControl\n        }));\n      } else {\n        return _jsx(ScrollView, _objectSpread({}, props));\n      }\n    };\n\n    _this._onCellLayout = function (e, cellKey, index) {\n      var layout = e.nativeEvent.layout;\n      var next = {\n        offset: _this._selectOffset(layout),\n        length: _this._selectLength(layout),\n        index: index,\n        inLayout: true\n      };\n      var curr = _this._frames[cellKey];\n\n      if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {\n        _this._totalCellLength += next.length - (curr ? curr.length : 0);\n        _this._totalCellsMeasured += curr ? 0 : 1;\n        _this._averageCellLength = _this._totalCellLength / _this._totalCellsMeasured;\n        _this._frames[cellKey] = next;\n        _this._highestMeasuredFrameIndex = Math.max(_this._highestMeasuredFrameIndex, index);\n\n        _this._scheduleCellsToRenderUpdate();\n      } else {\n        _this._frames[cellKey].inLayout = true;\n      }\n\n      _this._triggerRemeasureForChildListsInCell(cellKey);\n\n      _this._computeBlankness();\n\n      _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);\n    };\n\n    _this._onCellUnmount = function (cellKey) {\n      var curr = _this._frames[cellKey];\n\n      if (curr) {\n        _this._frames[cellKey] = _objectSpread(_objectSpread({}, curr), {}, {\n          inLayout: false\n        });\n      }\n    };\n\n    _this._onLayout = function (e) {\n      if (_this._isNestedWithSameOrientation()) {\n        _this.measureLayoutRelativeToContainingList();\n      } else {\n        _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);\n      }\n\n      _this.props.onLayout && _this.props.onLayout(e);\n\n      _this._scheduleCellsToRenderUpdate();\n\n      _this._maybeCallOnEndReached();\n    };\n\n    _this._onLayoutEmpty = function (e) {\n      _this.props.onLayout && _this.props.onLayout(e);\n    };\n\n    _this._onLayoutFooter = function (e) {\n      _this._triggerRemeasureForChildListsInCell(_this._getFooterCellKey());\n\n      _this._footerLength = _this._selectLength(e.nativeEvent.layout);\n    };\n\n    _this._onLayoutHeader = function (e) {\n      _this._headerLength = _this._selectLength(e.nativeEvent.layout);\n    };\n\n    _this._onContentSizeChange = function (width, height) {\n      if (width > 0 && height > 0 && _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 && !_this._hasTriggeredInitialScrollToIndex) {\n        if (_this.props.contentOffset == null) {\n          _this.scrollToIndex({\n            animated: false,\n            index: _this.props.initialScrollIndex\n          });\n        }\n\n        _this._hasTriggeredInitialScrollToIndex = true;\n      }\n\n      if (_this.props.onContentSizeChange) {\n        _this.props.onContentSizeChange(width, height);\n      }\n\n      _this._scrollMetrics.contentLength = _this._selectLength({\n        height: height,\n        width: width\n      });\n\n      _this._scheduleCellsToRenderUpdate();\n\n      _this._maybeCallOnEndReached();\n    };\n\n    _this._convertParentScrollMetrics = function (metrics) {\n      var offset = metrics.offset - _this._offsetFromParentVirtualizedList;\n      var visibleLength = metrics.visibleLength;\n      var dOffset = offset - _this._scrollMetrics.offset;\n      var contentLength = _this._scrollMetrics.contentLength;\n      return {\n        visibleLength: visibleLength,\n        contentLength: contentLength,\n        offset: offset,\n        dOffset: dOffset\n      };\n    };\n\n    _this._onScroll = function (e) {\n      _this._nestedChildLists.forEach(function (childList) {\n        childList._onScroll(e);\n      });\n\n      if (_this.props.onScroll) {\n        _this.props.onScroll(e);\n      }\n\n      var timestamp = e.timeStamp;\n\n      var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);\n\n      var contentLength = _this._selectLength(e.nativeEvent.contentSize);\n\n      var offset = _this._selectOffset(e.nativeEvent.contentOffset);\n\n      var dOffset = offset - _this._scrollMetrics.offset;\n\n      if (_this._isNestedWithSameOrientation()) {\n        if (_this._scrollMetrics.contentLength === 0) {\n          return;\n        }\n\n        var _this$_convertParentS = _this._convertParentScrollMetrics({\n          visibleLength: visibleLength,\n          offset: offset\n        });\n\n        visibleLength = _this$_convertParentS.visibleLength;\n        contentLength = _this$_convertParentS.contentLength;\n        offset = _this$_convertParentS.offset;\n        dOffset = _this$_convertParentS.dOffset;\n      }\n\n      var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;\n      var velocity = dOffset / dt;\n\n      if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {\n        infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {\n          dt: dt,\n          prevDt: _this._scrollMetrics.dt,\n          contentLength: contentLength\n        });\n        _this._hasWarned.perf = true;\n      }\n\n      var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n      _this._scrollMetrics = {\n        contentLength: contentLength,\n        dt: dt,\n        dOffset: dOffset,\n        offset: offset,\n        timestamp: timestamp,\n        velocity: velocity,\n        visibleLength: visibleLength,\n        zoomScale: zoomScale\n      };\n\n      _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);\n\n      if (!_this.props) {\n        return;\n      }\n\n      _this._maybeCallOnEndReached();\n\n      if (velocity !== 0) {\n        _this._fillRateHelper.activate();\n      }\n\n      _this._computeBlankness();\n\n      _this._scheduleCellsToRenderUpdate();\n    };\n\n    _this._onScrollBeginDrag = function (e) {\n      _this._nestedChildLists.forEach(function (childList) {\n        childList._onScrollBeginDrag(e);\n      });\n\n      _this._viewabilityTuples.forEach(function (tuple) {\n        tuple.viewabilityHelper.recordInteraction();\n      });\n\n      _this._hasInteracted = true;\n      _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);\n    };\n\n    _this._onScrollEndDrag = function (e) {\n      _this._nestedChildLists.forEach(function (childList) {\n        childList._onScrollEndDrag(e);\n      });\n\n      var velocity = e.nativeEvent.velocity;\n\n      if (velocity) {\n        _this._scrollMetrics.velocity = _this._selectOffset(velocity);\n      }\n\n      _this._computeBlankness();\n\n      _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);\n    };\n\n    _this._onMomentumScrollBegin = function (e) {\n      _this._nestedChildLists.forEach(function (childList) {\n        childList._onMomentumScrollBegin(e);\n      });\n\n      _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);\n    };\n\n    _this._onMomentumScrollEnd = function (e) {\n      _this._nestedChildLists.forEach(function (childList) {\n        childList._onMomentumScrollEnd(e);\n      });\n\n      _this._scrollMetrics.velocity = 0;\n\n      _this._computeBlankness();\n\n      _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);\n    };\n\n    _this._updateCellsToRender = function () {\n      _this.setState(function (state, props) {\n        var cellsAroundViewport = _this._adjustCellsAroundViewport(props, state.cellsAroundViewport);\n\n        var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, _this._getNonViewportRenderRegions(props));\n\n        if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {\n          return null;\n        }\n\n        return {\n          cellsAroundViewport: cellsAroundViewport,\n          renderMask: renderMask\n        };\n      });\n    };\n\n    _this._createViewToken = function (index, isViewable, props) {\n      var data = props.data,\n          getItem = props.getItem;\n      var item = getItem(data, index);\n      return {\n        index: index,\n        item: item,\n        key: _this._keyExtractor(item, index, props),\n        isViewable: isViewable\n      };\n    };\n\n    _this._getOffsetApprox = function (index, props) {\n      if (Number.isInteger(index)) {\n        return _this.__getFrameMetricsApprox(index, props).offset;\n      } else {\n        var frameMetrics = _this.__getFrameMetricsApprox(Math.floor(index), props);\n\n        var remainder = index - Math.floor(index);\n        return frameMetrics.offset + remainder * frameMetrics.length;\n      }\n    };\n\n    _this.__getFrameMetricsApprox = function (index, props) {\n      var frame = _this._getFrameMetrics(index, props);\n\n      if (frame && frame.index === index) {\n        return frame;\n      } else {\n        var data = props.data,\n            getItemCount = props.getItemCount,\n            getItemLayout = props.getItemLayout;\n        invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n        invariant(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');\n        return {\n          length: _this._averageCellLength,\n          offset: _this._averageCellLength * index\n        };\n      }\n    };\n\n    _this._getFrameMetrics = function (index, props) {\n      var data = props.data,\n          getItem = props.getItem,\n          getItemCount = props.getItemCount,\n          getItemLayout = props.getItemLayout;\n      invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n      var item = getItem(data, index);\n\n      var frame = item && _this._frames[_this._keyExtractor(item, index, props)];\n\n      if (!frame || frame.index !== index) {\n        if (getItemLayout) {\n          return getItemLayout(data, index);\n        }\n      }\n\n      return frame;\n    };\n\n    _this._getNonViewportRenderRegions = function (props) {\n      if (!(_this._lastFocusedCellKey && _this._cellRefs[_this._lastFocusedCellKey])) {\n        return [];\n      }\n\n      var lastFocusedCellRenderer = _this._cellRefs[_this._lastFocusedCellKey];\n      var focusedCellIndex = lastFocusedCellRenderer.props.index;\n      var itemCount = props.getItemCount(props.data);\n\n      if (focusedCellIndex >= itemCount || _this._indicesToKeys.get(focusedCellIndex) !== _this._lastFocusedCellKey) {\n        return [];\n      }\n\n      var first = focusedCellIndex;\n      var heightOfCellsBeforeFocused = 0;\n\n      for (var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < _this._scrollMetrics.visibleLength; i--) {\n        first--;\n        heightOfCellsBeforeFocused += _this.__getFrameMetricsApprox(i, props).length;\n      }\n\n      var last = focusedCellIndex;\n      var heightOfCellsAfterFocused = 0;\n\n      for (var _i = last + 1; _i < itemCount && heightOfCellsAfterFocused < _this._scrollMetrics.visibleLength; _i++) {\n        last++;\n        heightOfCellsAfterFocused += _this.__getFrameMetricsApprox(_i, props).length;\n      }\n\n      return [{\n        first: first,\n        last: last\n      }];\n    };\n\n    invariant(!_props.onScroll || !_props.onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');\n    invariant(windowSizeOrDefault(_props.windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');\n    invariant(_props.getItemCount, 'VirtualizedList: The \"getItemCount\" prop must be provided');\n    _this._fillRateHelper = new FillRateHelper(_this._getFrameMetrics);\n    _this._updateCellsToRenderBatcher = new Batchinator(_this._updateCellsToRender, (_this$props$updateCel = _this.props.updateCellsBatchingPeriod) != null ? _this$props$updateCel : 50);\n\n    if (_this.props.viewabilityConfigCallbackPairs) {\n      _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {\n        return {\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged\n        };\n      });\n    } else {\n      var _this$props = _this.props,\n          onViewableItemsChanged = _this$props.onViewableItemsChanged,\n          viewabilityConfig = _this$props.viewabilityConfig;\n\n      if (onViewableItemsChanged) {\n        _this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged\n        });\n      }\n    }\n\n    invariant(!_this.context, 'Unexpectedly saw VirtualizedListContext available in ctor');\n\n    var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);\n\n    _this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)\n    };\n    return _this;\n  }\n\n  _createClass(VirtualizedList, [{\n    key: \"scrollToEnd\",\n    value: function scrollToEnd(params) {\n      var animated = params ? params.animated : true;\n      var veryLast = this.props.getItemCount(this.props.data) - 1;\n\n      var frame = this.__getFrameMetricsApprox(veryLast, this.props);\n\n      var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);\n\n      if (this._scrollRef == null) {\n        return;\n      }\n\n      if (this._scrollRef.scrollTo == null) {\n        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n        return;\n      }\n\n      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {\n        x: offset,\n        animated: animated\n      } : {\n        y: offset,\n        animated: animated\n      });\n    }\n  }, {\n    key: \"scrollToIndex\",\n    value: function scrollToIndex(params) {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          horizontal = _this$props2.horizontal,\n          getItemCount = _this$props2.getItemCount,\n          getItemLayout = _this$props2.getItemLayout,\n          onScrollToIndexFailed = _this$props2.onScrollToIndexFailed;\n      var animated = params.animated,\n          index = params.index,\n          viewOffset = params.viewOffset,\n          viewPosition = params.viewPosition;\n      invariant(index >= 0, \"scrollToIndex out of range: requested index \" + index + \" but minimum is 0\");\n      invariant(getItemCount(data) >= 1, \"scrollToIndex out of range: item length \" + getItemCount(data) + \" but minimum is 1\");\n      invariant(index < getItemCount(data), \"scrollToIndex out of range: requested index \" + index + \" is out of 0 to \" + (getItemCount(data) - 1));\n\n      if (!getItemLayout && index > this._highestMeasuredFrameIndex) {\n        invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');\n        onScrollToIndexFailed({\n          averageItemLength: this._averageCellLength,\n          highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,\n          index: index\n        });\n        return;\n      }\n\n      var frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);\n\n      var offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);\n\n      if (this._scrollRef == null) {\n        return;\n      }\n\n      if (this._scrollRef.scrollTo == null) {\n        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n        return;\n      }\n\n      this._scrollRef.scrollTo(horizontal ? {\n        x: offset,\n        animated: animated\n      } : {\n        y: offset,\n        animated: animated\n      });\n    }\n  }, {\n    key: \"scrollToItem\",\n    value: function scrollToItem(params) {\n      var item = params.item;\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getItem = _this$props3.getItem,\n          getItemCount = _this$props3.getItemCount;\n      var itemCount = getItemCount(data);\n\n      for (var _index = 0; _index < itemCount; _index++) {\n        if (getItem(data, _index) === item) {\n          this.scrollToIndex(_objectSpread(_objectSpread({}, params), {}, {\n            index: _index\n          }));\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"scrollToOffset\",\n    value: function scrollToOffset(params) {\n      var animated = params.animated,\n          offset = params.offset;\n\n      if (this._scrollRef == null) {\n        return;\n      }\n\n      if (this._scrollRef.scrollTo == null) {\n        console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n        return;\n      }\n\n      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {\n        x: offset,\n        animated: animated\n      } : {\n        y: offset,\n        animated: animated\n      });\n    }\n  }, {\n    key: \"recordInteraction\",\n    value: function recordInteraction() {\n      this._nestedChildLists.forEach(function (childList) {\n        childList.recordInteraction();\n      });\n\n      this._viewabilityTuples.forEach(function (t) {\n        t.viewabilityHelper.recordInteraction();\n      });\n\n      this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    }\n  }, {\n    key: \"flashScrollIndicators\",\n    value: function flashScrollIndicators() {\n      if (this._scrollRef == null) {\n        return;\n      }\n\n      this._scrollRef.flashScrollIndicators();\n    }\n  }, {\n    key: \"getScrollResponder\",\n    value: function getScrollResponder() {\n      if (this._scrollRef && this._scrollRef.getScrollResponder) {\n        return this._scrollRef.getScrollResponder();\n      }\n    }\n  }, {\n    key: \"getScrollableNode\",\n    value: function getScrollableNode() {\n      if (this._scrollRef && this._scrollRef.getScrollableNode) {\n        return this._scrollRef.getScrollableNode();\n      } else {\n        return findNodeHandle(this._scrollRef);\n      }\n    }\n  }, {\n    key: \"getScrollRef\",\n    value: function getScrollRef() {\n      if (this._scrollRef && this._scrollRef.getScrollRef) {\n        return this._scrollRef.getScrollRef();\n      } else {\n        return this._scrollRef;\n      }\n    }\n  }, {\n    key: \"setNativeProps\",\n    value: function setNativeProps(props) {\n      if (this._scrollRef) {\n        this._scrollRef.setNativeProps(props);\n      }\n    }\n  }, {\n    key: \"_getCellKey\",\n    value: function _getCellKey() {\n      var _this$context;\n\n      return ((_this$context = this.context) == null ? void 0 : _this$context.cellKey) || 'rootList';\n    }\n  }, {\n    key: \"hasMore\",\n    value: function hasMore() {\n      return this._hasMore;\n    }\n  }, {\n    key: \"_adjustCellsAroundViewport\",\n    value: function _adjustCellsAroundViewport(props, cellsAroundViewport) {\n      var data = props.data,\n          getItemCount = props.getItemCount;\n      var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);\n\n      this._updateViewableItems(props, cellsAroundViewport);\n\n      var _this$_scrollMetrics = this._scrollMetrics,\n          contentLength = _this$_scrollMetrics.contentLength,\n          offset = _this$_scrollMetrics.offset,\n          visibleLength = _this$_scrollMetrics.visibleLength;\n      var distanceFromEnd = contentLength - visibleLength - offset;\n\n      if (visibleLength <= 0 || contentLength <= 0) {\n        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n      }\n\n      var newCellsAroundViewport;\n\n      if (props.disableVirtualization) {\n        var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;\n        newCellsAroundViewport = {\n          first: 0,\n          last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)\n        };\n      } else {\n        if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {\n          return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n        }\n\n        newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);\n        invariant(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');\n      }\n\n      if (this._nestedChildLists.size() > 0) {\n        var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);\n\n        newCellsAroundViewport.last = childIdx != null ? childIdx : newCellsAroundViewport.last;\n      }\n\n      return newCellsAroundViewport;\n    }\n  }, {\n    key: \"_findFirstChildWithMore\",\n    value: function _findFirstChildWithMore(first, last) {\n      for (var ii = first; ii <= last; ii++) {\n        var cellKeyForIndex = this._indicesToKeys.get(ii);\n\n        if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, function (childList) {\n          return childList.hasMore();\n        })) {\n          return ii;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this._isNestedWithSameOrientation()) {\n        this.context.registerAsNestedChild({\n          ref: this,\n          cellKey: this.context.cellKey\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._isNestedWithSameOrientation()) {\n        this.context.unregisterAsNestedChild({\n          ref: this\n        });\n      }\n\n      this._updateCellsToRenderBatcher.dispose({\n        abort: true\n      });\n\n      this._viewabilityTuples.forEach(function (tuple) {\n        tuple.viewabilityHelper.dispose();\n      });\n\n      this._fillRateHelper.deactivateAndFlush();\n    }\n  }, {\n    key: \"_pushCells\",\n    value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {\n      var _this2 = this;\n\n      var _this$props4 = this.props,\n          CellRendererComponent = _this$props4.CellRendererComponent,\n          ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,\n          ListHeaderComponent = _this$props4.ListHeaderComponent,\n          ListItemComponent = _this$props4.ListItemComponent,\n          data = _this$props4.data,\n          debug = _this$props4.debug,\n          getItem = _this$props4.getItem,\n          getItemCount = _this$props4.getItemCount,\n          getItemLayout = _this$props4.getItemLayout,\n          horizontal = _this$props4.horizontal,\n          renderItem = _this$props4.renderItem;\n      var stickyOffset = ListHeaderComponent ? 1 : 0;\n      var end = getItemCount(data) - 1;\n      var prevCellKey;\n      last = Math.min(end, last);\n\n      var _loop = function _loop(ii) {\n        var item = getItem(data, ii);\n\n        var key = _this2._keyExtractor(item, ii, _this2.props);\n\n        _this2._indicesToKeys.set(ii, key);\n\n        if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n          stickyHeaderIndices.push(cells.length);\n        }\n\n        cells.push(_jsx(CellRenderer, {\n          CellRendererComponent: CellRendererComponent,\n          ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,\n          ListItemComponent: ListItemComponent,\n          cellKey: key,\n          debug: debug,\n          fillRateHelper: _this2._fillRateHelper,\n          getItemLayout: getItemLayout,\n          horizontal: horizontal,\n          index: ii,\n          inversionStyle: inversionStyle,\n          item: item,\n          prevCellKey: prevCellKey,\n          onCellLayout: _this2._onCellLayout,\n          onUpdateSeparators: _this2._onUpdateSeparators,\n          onCellFocusCapture: function onCellFocusCapture(e) {\n            return _this2._onCellFocusCapture(key);\n          },\n          onUnmount: _this2._onCellUnmount,\n          ref: function ref(_ref) {\n            _this2._cellRefs[key] = _ref;\n          },\n          renderItem: renderItem\n        }, key));\n        prevCellKey = key;\n      };\n\n      for (var ii = first; ii <= last; ii++) {\n        _loop(ii);\n      }\n    }\n  }, {\n    key: \"_isNestedWithSameOrientation\",\n    value: function _isNestedWithSameOrientation() {\n      var nestedContext = this.context;\n      return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));\n    }\n  }, {\n    key: \"_keyExtractor\",\n    value: function _keyExtractor(item, index, props) {\n      if (props.keyExtractor != null) {\n        return props.keyExtractor(item, index);\n      }\n\n      var key = defaultKeyExtractor(item, index);\n\n      if (key === String(index)) {\n        _usedIndexForKey = true;\n\n        if (item.type && item.type.displayName) {\n          _keylessItemComponentName = item.type.displayName;\n        }\n      }\n\n      return key;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      if (__DEV__) {\n        var flatStyles = flattenStyle(this.props.contentContainerStyle);\n\n        if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n          console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');\n        }\n      }\n\n      var _this$props5 = this.props,\n          ListEmptyComponent = _this$props5.ListEmptyComponent,\n          ListFooterComponent = _this$props5.ListFooterComponent,\n          ListHeaderComponent = _this$props5.ListHeaderComponent;\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          horizontal = _this$props6.horizontal;\n      var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;\n      var cells = [];\n      var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n      var stickyHeaderIndices = [];\n\n      if (ListHeaderComponent) {\n        if (stickyIndicesFromProps.has(0)) {\n          stickyHeaderIndices.push(0);\n        }\n\n        var _element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : _jsx(ListHeaderComponent, {});\n\n        cells.push(_jsx(VirtualizedListCellContextProvider, {\n          cellKey: this._getCellKey() + '-header',\n          children: _jsx(View, {\n            onLayout: this._onLayoutHeader,\n            style: StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),\n            children: _element\n          })\n        }, \"$header\"));\n      }\n\n      var itemCount = this.props.getItemCount(data);\n\n      if (itemCount === 0 && ListEmptyComponent) {\n        var _element2 = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : _jsx(ListEmptyComponent, {});\n\n        cells.push(_jsx(VirtualizedListCellContextProvider, {\n          cellKey: this._getCellKey() + '-empty',\n          children: React.cloneElement(_element2, {\n            onLayout: function onLayout(event) {\n              _this3._onLayoutEmpty(event);\n\n              if (_element2.props.onLayout) {\n                _element2.props.onLayout(event);\n              }\n            },\n            style: StyleSheet.compose(inversionStyle, _element2.props.style)\n          })\n        }, \"$empty\"));\n      }\n\n      if (itemCount > 0) {\n        _usedIndexForKey = false;\n        _keylessItemComponentName = '';\n\n        var spacerKey = this._getSpacerKey(!horizontal);\n\n        var renderRegions = this.state.renderMask.enumerateRegions();\n        var lastSpacer = findLastWhere(renderRegions, function (r) {\n          return r.isSpacer;\n        });\n\n        for (var _iterator = _createForOfIteratorHelperLoose(renderRegions), _step; !(_step = _iterator()).done;) {\n          var section = _step.value;\n\n          if (section.isSpacer) {\n            if (this.props.disableVirtualization) {\n              continue;\n            }\n\n            var isLastSpacer = section === lastSpacer;\n            var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n            var last = constrainToMeasured ? clamp(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;\n\n            var firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);\n\n            var lastMetrics = this.__getFrameMetricsApprox(last, this.props);\n\n            var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n            cells.push(_jsx(View, {\n              style: _defineProperty({}, spacerKey, spacerSize)\n            }, \"$spacer-\" + section.first));\n          } else {\n            this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);\n          }\n        }\n\n        if (!this._hasWarned.keys && _usedIndexForKey) {\n          console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);\n          this._hasWarned.keys = true;\n        }\n      }\n\n      if (ListFooterComponent) {\n        var _element3 = React.isValidElement(ListFooterComponent) ? ListFooterComponent : _jsx(ListFooterComponent, {});\n\n        cells.push(_jsx(VirtualizedListCellContextProvider, {\n          cellKey: this._getFooterCellKey(),\n          children: _jsx(View, {\n            onLayout: this._onLayoutFooter,\n            style: StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),\n            children: _element3\n          })\n        }, \"$footer\"));\n      }\n\n      var scrollProps = _objectSpread(_objectSpread({}, this.props), {}, {\n        onContentSizeChange: this._onContentSizeChange,\n        onLayout: this._onLayout,\n        onScroll: this._onScroll,\n        onScrollBeginDrag: this._onScrollBeginDrag,\n        onScrollEndDrag: this._onScrollEndDrag,\n        onMomentumScrollBegin: this._onMomentumScrollBegin,\n        onMomentumScrollEnd: this._onMomentumScrollEnd,\n        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),\n        invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,\n        stickyHeaderIndices: stickyHeaderIndices,\n        style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style\n      });\n\n      this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n      var innerRet = _jsx(VirtualizedListContextProvider, {\n        value: {\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild\n        },\n        children: React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {\n          ref: this._captureScrollRef\n        }, cells)\n      });\n\n      var ret = innerRet;\n\n      if (__DEV__) {\n        ret = _jsx(ScrollView.Context.Consumer, {\n          children: function children(scrollContext) {\n            if (scrollContext != null && !scrollContext.horizontal === !horizontalOrDefault(_this3.props.horizontal) && !_this3._hasWarned.nesting && _this3.context == null && _this3.props.scrollEnabled !== false) {\n              console.error('VirtualizedLists should never be nested inside plain ScrollViews with the same ' + 'orientation because it can break windowing and other functionality - use another ' + 'VirtualizedList-backed container instead.');\n              _this3._hasWarned.nesting = true;\n            }\n\n            return innerRet;\n          }\n        });\n      }\n\n      if (this.props.debug) {\n        return _jsxs(View, {\n          style: styles.debug,\n          children: [ret, this._renderDebugOverlay()]\n        });\n      } else {\n        return ret;\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props7 = this.props,\n          data = _this$props7.data,\n          extraData = _this$props7.extraData;\n\n      if (data !== prevProps.data || extraData !== prevProps.extraData) {\n        this._viewabilityTuples.forEach(function (tuple) {\n          tuple.viewabilityHelper.resetViewableIndices();\n        });\n      }\n\n      var hiPriInProgress = this._hiPriInProgress;\n\n      this._scheduleCellsToRenderUpdate();\n\n      if (hiPriInProgress) {\n        this._hiPriInProgress = false;\n      }\n    }\n  }, {\n    key: \"_computeBlankness\",\n    value: function _computeBlankness() {\n      this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);\n    }\n  }, {\n    key: \"_onCellFocusCapture\",\n    value: function _onCellFocusCapture(cellKey) {\n      this._lastFocusedCellKey = cellKey;\n\n      var renderMask = VirtualizedList._createRenderMask(this.props, this.state.cellsAroundViewport, this._getNonViewportRenderRegions(this.props));\n\n      this.setState(function (state) {\n        if (!renderMask.equals(state.renderMask)) {\n          return {\n            renderMask: renderMask\n          };\n        }\n\n        return null;\n      });\n    }\n  }, {\n    key: \"_triggerRemeasureForChildListsInCell\",\n    value: function _triggerRemeasureForChildListsInCell(cellKey) {\n      this._nestedChildLists.forEachInCell(cellKey, function (childList) {\n        childList.measureLayoutRelativeToContainingList();\n      });\n    }\n  }, {\n    key: \"measureLayoutRelativeToContainingList\",\n    value: function measureLayoutRelativeToContainingList() {\n      var _this4 = this;\n\n      try {\n        if (!this._scrollRef) {\n          return;\n        }\n\n        this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), function (x, y, width, height) {\n          _this4._offsetFromParentVirtualizedList = _this4._selectOffset({\n            x: x,\n            y: y\n          });\n          _this4._scrollMetrics.contentLength = _this4._selectLength({\n            width: width,\n            height: height\n          });\n\n          var scrollMetrics = _this4._convertParentScrollMetrics(_this4.context.getScrollMetrics());\n\n          var metricsChanged = _this4._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || _this4._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            _this4._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            _this4._scrollMetrics.offset = scrollMetrics.offset;\n\n            _this4._nestedChildLists.forEach(function (childList) {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        }, function (error) {\n          console.warn(\"VirtualizedList: Encountered an error while measuring a list's\" + ' offset from its containing VirtualizedList.');\n        });\n      } catch (error) {\n        console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);\n      }\n    }\n  }, {\n    key: \"_getFooterCellKey\",\n    value: function _getFooterCellKey() {\n      return this._getCellKey() + '-footer';\n    }\n  }, {\n    key: \"_renderDebugOverlay\",\n    value: function _renderDebugOverlay() {\n      var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);\n      var framesInLayout = [];\n      var itemCount = this.props.getItemCount(this.props.data);\n\n      for (var ii = 0; ii < itemCount; ii++) {\n        var frame = this.__getFrameMetricsApprox(ii, this.props);\n\n        if (frame.inLayout) {\n          framesInLayout.push(frame);\n        }\n      }\n\n      var windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;\n\n      var frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);\n\n      var windowLen = frameLast.offset + frameLast.length - windowTop;\n      var visTop = this._scrollMetrics.offset;\n      var visLen = this._scrollMetrics.visibleLength;\n      return _jsxs(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlay],\n        children: [framesInLayout.map(function (f, ii) {\n          return _jsx(View, {\n            style: [styles.debugOverlayBase, styles.debugOverlayFrame, {\n              top: f.offset * normalize,\n              height: f.length * normalize\n            }]\n          }, 'f' + ii);\n        }), _jsx(View, {\n          style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {\n            top: windowTop * normalize,\n            height: windowLen * normalize\n          }]\n        }), _jsx(View, {\n          style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {\n            top: visTop * normalize,\n            height: visLen * normalize\n          }]\n        })]\n      });\n    }\n  }, {\n    key: \"_selectLength\",\n    value: function _selectLength(metrics) {\n      return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;\n    }\n  }, {\n    key: \"_selectOffset\",\n    value: function _selectOffset(metrics) {\n      return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;\n    }\n  }, {\n    key: \"_maybeCallOnEndReached\",\n    value: function _maybeCallOnEndReached() {\n      var _this$props8 = this.props,\n          data = _this$props8.data,\n          getItemCount = _this$props8.getItemCount,\n          onEndReached = _this$props8.onEndReached,\n          onEndReachedThreshold = _this$props8.onEndReachedThreshold;\n      var _this$_scrollMetrics2 = this._scrollMetrics,\n          contentLength = _this$_scrollMetrics2.contentLength,\n          visibleLength = _this$_scrollMetrics2.visibleLength,\n          offset = _this$_scrollMetrics2.offset;\n      var distanceFromEnd = contentLength - visibleLength - offset;\n\n      if (distanceFromEnd < ON_END_REACHED_EPSILON) {\n        distanceFromEnd = 0;\n      }\n\n      var threshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : 2;\n\n      if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && distanceFromEnd <= threshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {\n        this._sentEndForContentLength = this._scrollMetrics.contentLength;\n        onEndReached({\n          distanceFromEnd: distanceFromEnd\n        });\n      } else if (distanceFromEnd > threshold) {\n        this._sentEndForContentLength = 0;\n      }\n    }\n  }, {\n    key: \"_scheduleCellsToRenderUpdate\",\n    value: function _scheduleCellsToRenderUpdate() {\n      var _this$state$cellsArou = this.state.cellsAroundViewport,\n          first = _this$state$cellsArou.first,\n          last = _this$state$cellsArou.last;\n      var _this$_scrollMetrics3 = this._scrollMetrics,\n          offset = _this$_scrollMetrics3.offset,\n          visibleLength = _this$_scrollMetrics3.visibleLength,\n          velocity = _this$_scrollMetrics3.velocity;\n      var itemCount = this.props.getItemCount(this.props.data);\n      var hiPri = false;\n      var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);\n      var scrollingThreshold = onEndReachedThreshold * visibleLength / 2;\n\n      if (first > 0) {\n        var distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;\n\n        hiPri = hiPri || distTop < 0 || velocity < -2 && distTop < scrollingThreshold;\n      }\n\n      if (last >= 0 && last < itemCount - 1) {\n        var distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);\n        hiPri = hiPri || distBottom < 0 || velocity > 2 && distBottom < scrollingThreshold;\n      }\n\n      if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {\n        this._hiPriInProgress = true;\n\n        this._updateCellsToRenderBatcher.dispose({\n          abort: true\n        });\n\n        this._updateCellsToRender();\n\n        return;\n      } else {\n        this._updateCellsToRenderBatcher.schedule();\n      }\n    }\n  }, {\n    key: \"_updateViewableItems\",\n    value: function _updateViewableItems(props, cellsAroundViewport) {\n      var _this5 = this;\n\n      this._viewabilityTuples.forEach(function (tuple) {\n        tuple.viewabilityHelper.onUpdate(props, _this5._scrollMetrics.offset, _this5._scrollMetrics.visibleLength, _this5._getFrameMetrics, _this5._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);\n      });\n    }\n  }], [{\n    key: \"_createRenderMask\",\n    value: function _createRenderMask(props, cellsAroundViewport, additionalRegions) {\n      var itemCount = props.getItemCount(props.data);\n      invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, \"Invalid cells around viewport \\\"[\" + cellsAroundViewport.first + \", \" + cellsAroundViewport.last + \"]\\\" was passed to VirtualizedList._createRenderMask\");\n      var renderMask = new CellRenderMask(itemCount);\n\n      if (itemCount > 0) {\n        var allRegions = [cellsAroundViewport].concat(_toConsumableArray(additionalRegions != null ? additionalRegions : []));\n\n        for (var _iterator2 = _createForOfIteratorHelperLoose(allRegions), _step2; !(_step2 = _iterator2()).done;) {\n          var region = _step2.value;\n          renderMask.addCells(region);\n        }\n\n        if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n          var initialRegion = VirtualizedList._initialRenderRegion(props);\n\n          renderMask.addCells(initialRegion);\n        }\n\n        var stickyIndicesSet = new Set(props.stickyHeaderIndices);\n\n        VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);\n      }\n\n      return renderMask;\n    }\n  }, {\n    key: \"_initialRenderRegion\",\n    value: function _initialRenderRegion(props) {\n      var _props$initialScrollI;\n\n      var itemCount = props.getItemCount(props.data);\n      var scrollIndex = Math.floor(Math.max(0, (_props$initialScrollI = props.initialScrollIndex) != null ? _props$initialScrollI : 0));\n      return {\n        first: scrollIndex,\n        last: Math.min(itemCount, scrollIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1\n      };\n    }\n  }, {\n    key: \"_ensureClosestStickyHeader\",\n    value: function _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {\n      var stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n      for (var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n        if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n          renderMask.addCells({\n            first: itemIdx,\n            last: itemIdx\n          });\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(newProps, prevState) {\n      var itemCount = newProps.getItemCount(newProps.data);\n\n      if (itemCount === prevState.renderMask.numCells()) {\n        return prevState;\n      }\n\n      var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);\n\n      return {\n        cellsAroundViewport: constrainedCells,\n        renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)\n      };\n    }\n  }, {\n    key: \"_constrainToItemCount\",\n    value: function _constrainToItemCount(cells, props) {\n      var itemCount = props.getItemCount(props.data);\n      var last = Math.min(itemCount - 1, cells.last);\n      var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);\n      return {\n        first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),\n        last: last\n      };\n    }\n  }]);\n\n  return VirtualizedList;\n}(StateSafePureComponent);\n\nVirtualizedList.contextType = VirtualizedListContext;\nexport { VirtualizedList as default };\nvar styles = StyleSheet.create({\n  verticallyInverted: {\n    transform: [{\n      scaleY: -1\n    }]\n  },\n  horizontallyInverted: {\n    transform: [{\n      scaleX: -1\n    }]\n  },\n  debug: {\n    flex: 1\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange'\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2\n  }\n});","map":{"version":3,"names":["RefreshControl","ScrollView","View","Batchinator","findNodeHandle","flattenStyle","StyleSheet","clamp","infoLog","CellRenderMask","ChildListCollection","FillRateHelper","StateSafePureComponent","ViewabilityHelper","CellRenderer","VirtualizedListCellContextProvider","VirtualizedListContext","VirtualizedListContextProvider","computeWindowedRenderLimits","keyExtractor","defaultKeyExtractor","invariant","React","ON_END_REACHED_EPSILON","_usedIndexForKey","_keylessItemComponentName","horizontalOrDefault","horizontal","initialNumToRenderOrDefault","initialNumToRender","maxToRenderPerBatchOrDefault","maxToRenderPerBatch","onEndReachedThresholdOrDefault","onEndReachedThreshold","scrollEventThrottleOrDefault","scrollEventThrottle","windowSizeOrDefault","windowSize","findLastWhere","arr","predicate","i","length","VirtualizedList","props","_getScrollMetrics","_scrollMetrics","_getOutermostParentListRef","_isNestedWithSameOrientation","context","getOutermostParentListRef","_registerAsNestedChild","childList","_nestedChildLists","add","ref","cellKey","_hasInteracted","recordInteraction","_unregisterAsNestedChild","remove","_onUpdateSeparators","keys","newProps","forEach","key","_cellRefs","updateSeparatorProps","_getSpacerKey","isVertical","_averageCellLength","_frames","_footerLength","_hasTriggeredInitialScrollToIndex","_hasMore","_hasWarned","_headerLength","_hiPriInProgress","_highestMeasuredFrameIndex","_indicesToKeys","Map","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_prevParentOffset","contentLength","dOffset","dt","offset","timestamp","velocity","visibleLength","zoomScale","_scrollRef","_sentEndForContentLength","_totalCellLength","_totalCellsMeasured","_viewabilityTuples","_captureScrollRef","_defaultRenderScrollComponent","onRefresh","refreshing","JSON","stringify","refreshControl","progressViewOffset","_onCellLayout","e","index","layout","nativeEvent","next","_selectOffset","_selectLength","inLayout","curr","Math","max","_scheduleCellsToRenderUpdate","_triggerRemeasureForChildListsInCell","_computeBlankness","_updateViewableItems","state","cellsAroundViewport","_onCellUnmount","_onLayout","measureLayoutRelativeToContainingList","onLayout","_maybeCallOnEndReached","_onLayoutEmpty","_onLayoutFooter","_getFooterCellKey","_onLayoutHeader","_onContentSizeChange","width","height","initialScrollIndex","contentOffset","scrollToIndex","animated","onContentSizeChange","_convertParentScrollMetrics","metrics","_onScroll","onScroll","timeStamp","layoutMeasurement","contentSize","perf","prevDt","_fillRateHelper","activate","_onScrollBeginDrag","tuple","viewabilityHelper","onScrollBeginDrag","_onScrollEndDrag","onScrollEndDrag","_onMomentumScrollBegin","onMomentumScrollBegin","_onMomentumScrollEnd","onMomentumScrollEnd","_updateCellsToRender","setState","_adjustCellsAroundViewport","renderMask","_createRenderMask","_getNonViewportRenderRegions","first","last","equals","_createViewToken","isViewable","data","getItem","item","_keyExtractor","_getOffsetApprox","Number","isInteger","__getFrameMetricsApprox","frameMetrics","floor","remainder","frame","_getFrameMetrics","getItemCount","getItemLayout","lastFocusedCellRenderer","focusedCellIndex","itemCount","get","heightOfCellsBeforeFocused","heightOfCellsAfterFocused","__isNative","_updateCellsToRenderBatcher","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","map","pair","viewabilityConfig","onViewableItemsChanged","push","initialRenderRegion","_initialRenderRegion","params","veryLast","scrollTo","console","warn","x","y","onScrollToIndexFailed","viewOffset","viewPosition","averageItemLength","highestMeasuredFrameIndex","t","flashScrollIndicators","getScrollResponder","getScrollableNode","getScrollRef","setNativeProps","distanceFromEnd","_constrainToItemCount","newCellsAroundViewport","disableVirtualization","renderAhead","min","abs","EPSILON","size","childIdx","_findFirstChildWithMore","ii","cellKeyForIndex","anyInCell","hasMore","registerAsNestedChild","unregisterAsNestedChild","dispose","abort","deactivateAndFlush","cells","stickyHeaderIndices","stickyIndicesFromProps","inversionStyle","CellRendererComponent","ItemSeparatorComponent","ListHeaderComponent","ListItemComponent","debug","renderItem","stickyOffset","end","prevCellKey","set","has","undefined","_onCellFocusCapture","nestedContext","String","type","displayName","__DEV__","flatStyles","contentContainerStyle","flexWrap","ListEmptyComponent","ListFooterComponent","inverted","styles","horizontallyInverted","verticallyInverted","Set","element","isValidElement","_getCellKey","compose","ListHeaderComponentStyle","cloneElement","event","style","spacerKey","renderRegions","enumerateRegions","lastSpacer","r","isSpacer","section","isLastSpacer","constrainToMeasured","firstMetrics","lastMetrics","spacerSize","_pushCells","ListFooterComponentStyle","scrollProps","invertStickyHeaders","innerRet","getScrollMetrics","renderScrollComponent","ret","scrollContext","nesting","scrollEnabled","error","_renderDebugOverlay","prevProps","extraData","resetViewableIndices","hiPriInProgress","computeBlankness","forEachInCell","measureLayout","scrollMetrics","metricsChanged","stack","normalize","framesInLayout","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","top","debugOverlayFrameLast","debugOverlayFrameVis","onEndReached","threshold","hiPri","scrollingThreshold","distTop","distBottom","schedule","onUpdate","additionalRegions","allRegions","region","addCells","initialRegion","stickyIndicesSet","_ensureClosestStickyHeader","scrollIndex","cellIdx","itemIdx","prevState","numCells","constrainedCells","contextType","create","transform","scaleY","scaleX","flex","position","right","bottom","borderColor","borderWidth","left","backgroundColor"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/Lists/VirtualizedList.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {ScrollResponderType} from '../Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from '../StyleSheet/StyleSheet';\nimport type {LayoutEvent, ScrollEvent} from '../Types/CoreEventTypes';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  FrameMetricProps,\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\n\nimport RefreshControl from '../Components/RefreshControl/RefreshControl';\nimport ScrollView from '../Components/ScrollView/ScrollView';\nimport View from '../Components/View/View';\nimport Batchinator from '../Interaction/Batchinator';\nimport {findNodeHandle} from '../ReactNative/RendererProxy';\nimport flattenStyle from '../StyleSheet/flattenStyle';\nimport StyleSheet from '../StyleSheet/StyleSheet';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport * as React from 'react';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_END_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n};\n\n/**\n * Default Props Helper Functions\n * Use the following helper functions for default values\n */\n\n// horizontalOrDefault(this.props.horizontal)\nfunction horizontalOrDefault(horizontal: ?boolean) {\n  return horizontal ?? false;\n}\n\n// initialNumToRenderOrDefault(this.props.initialNumToRenderOrDefault)\nfunction initialNumToRenderOrDefault(initialNumToRender: ?number) {\n  return initialNumToRender ?? 10;\n}\n\n// maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)\nfunction maxToRenderPerBatchOrDefault(maxToRenderPerBatch: ?number) {\n  return maxToRenderPerBatch ?? 10;\n}\n\n// onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)\nfunction onEndReachedThresholdOrDefault(onEndReachedThreshold: ?number) {\n  return onEndReachedThreshold ?? 2;\n}\n\n// scrollEventThrottleOrDefault(this.props.scrollEventThrottle)\nfunction scrollEventThrottleOrDefault(scrollEventThrottle: ?number) {\n  return scrollEventThrottle ?? 50;\n}\n\n// windowSizeOrDefault(this.props.windowSize)\nfunction windowSizeOrDefault(windowSize: ?number) {\n  return windowSize ?? 21;\n}\n\nfunction findLastWhere<T>(\n  arr: $ReadOnlyArray<T>,\n  predicate: (element: T) => boolean,\n): T | null {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (predicate(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nexport default class VirtualizedList extends StateSafePureComponent<\n  Props,\n  State,\n> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    const frame = this.__getFrameMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontalOrDefault(this.props.horizontal)\n        ? {x: offset, animated}\n        : {y: offset, animated},\n    );\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {\n      data,\n      horizontal,\n      getItemCount,\n      getItemLayout,\n      onScrollToIndexFailed,\n    } = this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (!getItemLayout && index > this._highestMeasuredFrameIndex) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._averageCellLength,\n        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,\n        index,\n      });\n      return;\n    }\n    const frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);\n    const offset =\n      Math.max(\n        0,\n        this._getOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontal ? {x: offset, animated} : {y: offset, animated},\n    );\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    if (this._scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    this._scrollRef.scrollTo(\n      horizontalOrDefault(this.props.horizontal)\n        ? {x: offset, animated}\n        : {y: offset, animated},\n    );\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !props.onScroll || !props.onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(props.windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      props.getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    this._fillRateHelper = new FillRateHelper(this._getFrameMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    invariant(\n      !this.context,\n      'Unexpectedly saw VirtualizedListContext available in ctor',\n    );\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n    };\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const scrollIndex = Math.floor(Math.max(0, props.initialScrollIndex ?? 0));\n\n    return {\n      first: scrollIndex,\n      last:\n        Math.min(\n          itemCount,\n          scrollIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n        ) - 1,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    this._updateViewableItems(props, cellsAroundViewport);\n\n    const {contentLength, offset, visibleLength} = this._scrollMetrics;\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a non-zero initialScrollIndex and run this before we've scrolled,\n      // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.\n      // So let's wait until we've scrolled the view to the right place. And until then,\n      // we will trust the initialScrollIndex suggestion.\n\n      // Thus, we want to recalculate the windowed render limits if any of the following hold:\n      // - initialScrollIndex is undefined or is 0\n      // - initialScrollIndex > 0 AND scrolling is complete\n      // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case\n      //   where the list is shorter than the visible area)\n      if (\n        props.initialScrollIndex &&\n        !this._scrollMetrics.offset &&\n        Math.abs(distanceFromEnd) >= Number.EPSILON\n      ) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this.__getFrameMetricsApprox,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = this._keyExtractor(item, ii, this.props);\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          debug={debug}\n          fillRateHelper={this._fillRateHelper}\n          getItemLayout={getItemLayout}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onCellLayout={this._onCellLayout}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={e => this._onCellFocusCapture(key)}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const last = Math.min(itemCount - 1, cells.last);\n\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n\n    return {\n      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),\n      last,\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n    // $FlowFixMe[missing-local-annot]\n  ) {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    if (__DEV__) {\n      const flatStyles = flattenStyle(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n      }\n    }\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: React.Element<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._highestMeasuredFrameIndex,\n              )\n            : section.last;\n\n          const firstMetrics = this.__getFrameMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this.__getFrameMetricsApprox(last, this.props);\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      scrollEventThrottle: scrollEventThrottleOrDefault(\n        this.props.scrollEventThrottle,\n      ), // TODO: Android support\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _averageCellLength = 0;\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _frames: {\n    [string]: {\n      inLayout?: boolean,\n      index: number,\n      length: number,\n      offset: number,\n    },\n  } = {};\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _highestMeasuredFrameIndex = 0;\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _prevParentOffset: number = 0;\n  // $FlowFixMe[missing-local-annot]\n  _scrollMetrics = {\n    contentLength: 0,\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentEndForContentLength = 0;\n  _totalCellLength = 0;\n  _totalCellsMeasured = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors\n      return <View {...props} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (e: LayoutEvent, cellKey: string, index: number): void => {\n    const layout = e.nativeEvent.layout;\n    const next = {\n      offset: this._selectOffset(layout),\n      length: this._selectLength(layout),\n      index,\n      inLayout: true,\n    };\n    const curr = this._frames[cellKey];\n    if (\n      !curr ||\n      next.offset !== curr.offset ||\n      next.length !== curr.length ||\n      index !== curr.index\n    ) {\n      this._totalCellLength += next.length - (curr ? curr.length : 0);\n      this._totalCellsMeasured += curr ? 0 : 1;\n      this._averageCellLength =\n        this._totalCellLength / this._totalCellsMeasured;\n      this._frames[cellKey] = next;\n      this._highestMeasuredFrameIndex = Math.max(\n        this._highestMeasuredFrameIndex,\n        index,\n      );\n      this._scheduleCellsToRenderUpdate();\n    } else {\n      this._frames[cellKey].inLayout = true;\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture(cellKey: string) {\n    this._lastFocusedCellKey = cellKey;\n    const renderMask = VirtualizedList._createRenderMask(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._getNonViewportRenderRegions(this.props),\n    );\n\n    this.setState(state => {\n      if (!renderMask.equals(state.renderMask)) {\n        return {renderMask};\n      }\n      return null;\n    });\n  }\n\n  _onCellUnmount = (cellKey: string) => {\n    const curr = this._frames[cellKey];\n    if (curr) {\n      this._frames[cellKey] = {...curr, inLayout: false};\n    }\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._scrollMetrics.contentLength = this._selectLength({\n            width,\n            height,\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEndReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._scrollMetrics.contentLength || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this.__getFrameMetricsApprox(ii, this.props);\n      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment\n       * suppresses an error found when Flow v0.68 was deployed. To see the\n       * error delete this comment and run Flow. */\n      if (frame.inLayout) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this.__getFrameMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this.__getFrameMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset(\n    metrics: $ReadOnly<{\n      x: number,\n      y: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;\n  }\n\n  _maybeCallOnEndReached() {\n    const {data, getItemCount, onEndReached, onEndReachedThreshold} =\n      this.props;\n    const {contentLength, visibleLength, offset} = this._scrollMetrics;\n    let distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distanceFromEnd values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the \"end\" of the list with a distanceFromEnd approximating 0 but not quite there.\n    if (distanceFromEnd < ON_END_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2 when oERT is not present\n    const threshold =\n      onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : 2;\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      distanceFromEnd <= threshold &&\n      this._scrollMetrics.contentLength !== this._sentEndForContentLength\n    ) {\n      // Only call onEndReached once for a given content length\n      this._sentEndForContentLength = this._scrollMetrics.contentLength;\n      onEndReached({distanceFromEnd});\n    } else if (distanceFromEnd > threshold) {\n      // If the user scrolls away from the end and back again cause\n      // an onEndReached to be triggered again\n      this._sentEndForContentLength = 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    if (\n      width > 0 &&\n      height > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        this.scrollToIndex({\n          animated: false,\n          index: this.props.initialScrollIndex,\n        });\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scrollMetrics.contentLength = this._selectLength({height, width});\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEndReached();\n  };\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._scrollMetrics.contentLength;\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._selectOffset(e.nativeEvent.contentOffset);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._scrollMetrics.contentLength === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      contentLength,\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEndReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _scheduleCellsToRenderUpdate() {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    const scrollingThreshold = (onEndReachedThreshold * visibleLength) / 2;\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset - this.__getFrameMetricsApprox(first, this.props).offset;\n      hiPri =\n        hiPri || distTop < 0 || (velocity < -2 && distTop < scrollingThreshold);\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this.__getFrameMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        hiPri ||\n        distBottom < 0 ||\n        (velocity > 2 && distBottom < scrollingThreshold);\n    }\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      hiPri &&\n      (this._averageCellLength || this.props.getItemLayout) &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: FrameMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: this._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  _getOffsetApprox = (index: number, props: FrameMetricProps): number => {\n    if (Number.isInteger(index)) {\n      return this.__getFrameMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.__getFrameMetricsApprox(\n        Math.floor(index),\n        props,\n      );\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  };\n\n  __getFrameMetricsApprox: (\n    index: number,\n    props: FrameMetricProps,\n  ) => {\n    length: number,\n    offset: number,\n    ...\n  } = (index, props) => {\n    const frame = this._getFrameMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount, getItemLayout} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      invariant(\n        !getItemLayout,\n        'Should not have to estimate frames when a measurement metrics function is provided',\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n      };\n    }\n  };\n\n  _getFrameMetrics = (\n    index: number,\n    props: FrameMetricProps,\n  ): ?{\n    length: number,\n    offset: number,\n    index: number,\n    inLayout?: boolean,\n    ...\n  } => {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get frame for out of range index ' + index,\n    );\n    const item = getItem(data, index);\n    const frame = item && this._frames[this._keyExtractor(item, index, props)];\n    if (!frame || frame.index !== index) {\n      if (getItemLayout) {\n        /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment\n         * suppresses an error found when Flow v0.63 was deployed. To see the error\n         * delete this comment and run Flow. */\n        return getItemLayout(data, index);\n      }\n    }\n    return frame;\n  };\n\n  _getNonViewportRenderRegions = (\n    props: FrameMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The cell may have been unmounted and have a stale index\n    if (\n      focusedCellIndex >= itemCount ||\n      this._indicesToKeys.get(focusedCellIndex) !== this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this.__getFrameMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: FrameMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._getFrameMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted: {\n    transform: [{scaleY: -1}],\n  },\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}