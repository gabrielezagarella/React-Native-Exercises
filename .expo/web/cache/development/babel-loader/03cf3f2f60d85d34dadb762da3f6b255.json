{"ast":null,"code":"import NativeTiming from \"./NativeTiming\";\n\nvar BatchedBridge = require(\"../../BatchedBridge/BatchedBridge\");\n\nvar Systrace = require(\"../../Performance/Systrace\");\n\nvar invariant = require('invariant');\n\nvar FRAME_DURATION = 1000 / 60;\nvar IDLE_CALLBACK_FRAME_DEADLINE = 1;\nvar callbacks = [];\nvar types = [];\nvar timerIDs = [];\nvar reactNativeMicrotasks = [];\nvar requestIdleCallbacks = [];\nvar requestIdleCallbackTimeouts = {};\nvar GUID = 1;\nvar errors = [];\nvar hasEmittedTimeDriftWarning = false;\n\nfunction _getFreeIndex() {\n  var freeIndex = timerIDs.indexOf(null);\n\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n\n  return freeIndex;\n}\n\nfunction _allocateCallback(func, type) {\n  var id = GUID++;\n\n  var freeIndex = _getFreeIndex();\n\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\n\nfunction _callTimer(timerID, frameTime, didTimeout) {\n  if (timerID > GUID) {\n    console.warn('Tried to call timer with ID %s but no such timer exists.', timerID);\n  }\n\n  var timerIndex = timerIDs.indexOf(timerID);\n\n  if (timerIndex === -1) {\n    return;\n  }\n\n  var type = types[timerIndex];\n  var callback = callbacks[timerIndex];\n\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (type === 'setTimeout' || type === 'setInterval' || type === 'queueReactNativeMicrotask') {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(global.performance.now());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function timeRemaining() {\n          return Math.max(0, FRAME_DURATION - (global.performance.now() - frameTime));\n        },\n        didTimeout: !!didTimeout\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    errors.push(e);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\nfunction _callReactNativeMicrotasksPass() {\n  if (reactNativeMicrotasks.length === 0) {\n    return false;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent('callReactNativeMicrotasksPass()');\n  }\n\n  var passReactNativeMicrotasks = reactNativeMicrotasks;\n  reactNativeMicrotasks = [];\n\n  for (var i = 0; i < passReactNativeMicrotasks.length; ++i) {\n    _callTimer(passReactNativeMicrotasks[i], 0);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n\n  return reactNativeMicrotasks.length > 0;\n}\n\nfunction _clearIndex(i) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\n\nfunction _freeCallback(timerID) {\n  if (timerID == null) {\n    return;\n  }\n\n  var index = timerIDs.indexOf(timerID);\n\n  if (index !== -1) {\n    var type = types[index];\n\n    _clearIndex(index);\n\n    if (type !== 'queueReactNativeMicrotask' && type !== 'requestIdleCallback') {\n      deleteTimer(timerID);\n    }\n  }\n}\n\nvar JSTimers = {\n  setTimeout: function setTimeout(func, duration) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setTimeout');\n\n    createTimer(id, duration || 0, Date.now(), false);\n    return id;\n  },\n  setInterval: function setInterval(func, duration) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'setInterval');\n\n    createTimer(id, duration || 0, Date.now(), true);\n    return id;\n  },\n  queueReactNativeMicrotask: function queueReactNativeMicrotask(func) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    var id = _allocateCallback(function () {\n      return func.apply(undefined, args);\n    }, 'queueReactNativeMicrotask');\n\n    reactNativeMicrotasks.push(id);\n    return id;\n  },\n  requestAnimationFrame: function requestAnimationFrame(func) {\n    var id = _allocateCallback(func, 'requestAnimationFrame');\n\n    createTimer(id, 1, Date.now(), false);\n    return id;\n  },\n  requestIdleCallback: function requestIdleCallback(func, options) {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n\n    var timeout = options && options.timeout;\n\n    var id = _allocateCallback(timeout != null ? function (deadline) {\n      var timeoutId = requestIdleCallbackTimeouts[id];\n\n      if (timeoutId) {\n        JSTimers.clearTimeout(timeoutId);\n        delete requestIdleCallbackTimeouts[id];\n      }\n\n      return func(deadline);\n    } : func, 'requestIdleCallback');\n\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      var timeoutId = JSTimers.setTimeout(function () {\n        var index = requestIdleCallbacks.indexOf(id);\n\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n\n          _callTimer(id, global.performance.now(), true);\n        }\n\n        delete requestIdleCallbackTimeouts[id];\n\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n\n    return id;\n  },\n  cancelIdleCallback: function cancelIdleCallback(timerID) {\n    _freeCallback(timerID);\n\n    var index = requestIdleCallbacks.indexOf(timerID);\n\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    var timeoutId = requestIdleCallbackTimeouts[timerID];\n\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n  clearTimeout: function clearTimeout(timerID) {\n    _freeCallback(timerID);\n  },\n  clearInterval: function clearInterval(timerID) {\n    _freeCallback(timerID);\n  },\n  clearReactNativeMicrotask: function clearReactNativeMicrotask(timerID) {\n    _freeCallback(timerID);\n\n    var index = reactNativeMicrotasks.indexOf(timerID);\n\n    if (index !== -1) {\n      reactNativeMicrotasks.splice(index, 1);\n    }\n  },\n  cancelAnimationFrame: function cancelAnimationFrame(timerID) {\n    _freeCallback(timerID);\n  },\n  callTimers: function callTimers(timersToCall) {\n    invariant(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');\n    errors.length = 0;\n\n    for (var i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    var errorCount = errors.length;\n\n    if (errorCount > 0) {\n      if (errorCount > 1) {\n        for (var ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(function (error) {\n            throw error;\n          }.bind(null, errors[ii]), 0);\n        }\n      }\n\n      throw errors[0];\n    }\n  },\n  callIdleCallbacks: function callIdleCallbacks(frameTime) {\n    if (FRAME_DURATION - (global.performance.now() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n\n    errors.length = 0;\n\n    if (requestIdleCallbacks.length > 0) {\n      var passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n\n      for (var i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n\n    errors.forEach(function (error) {\n      return JSTimers.setTimeout(function () {\n        throw error;\n      }, 0);\n    });\n  },\n  callReactNativeMicrotasks: function callReactNativeMicrotasks() {\n    errors.length = 0;\n\n    while (_callReactNativeMicrotasksPass()) {}\n\n    errors.forEach(function (error) {\n      return JSTimers.setTimeout(function () {\n        throw error;\n      }, 0);\n    });\n  },\n  emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  }\n};\n\nfunction createTimer(callbackID, duration, jsSchedulingTime, repeats) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\n\nfunction deleteTimer(timerID) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\n\nfunction setSendIdleEvents(sendIdleEvents) {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\n\nvar ExportedJSTimers;\n\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  ExportedJSTimers = {\n    callReactNativeMicrotasks: JSTimers.callReactNativeMicrotasks,\n    queueReactNativeMicrotask: JSTimers.queueReactNativeMicrotask\n  };\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setReactNativeMicrotasksCallback(JSTimers.callReactNativeMicrotasks);\nmodule.exports = ExportedJSTimers;","map":{"version":3,"names":["NativeTiming","BatchedBridge","require","Systrace","invariant","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","callbacks","types","timerIDs","reactNativeMicrotasks","requestIdleCallbacks","requestIdleCallbackTimeouts","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","_callTimer","timerID","frameTime","didTimeout","console","warn","timerIndex","callback","error","__DEV__","beginEvent","_clearIndex","global","performance","now","timeRemaining","Math","max","e","push","endEvent","_callReactNativeMicrotasksPass","passReactNativeMicrotasks","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","args","apply","undefined","createTimer","Date","setInterval","queueReactNativeMicrotask","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","deadline","timeoutId","clearTimeout","splice","cancelIdleCallback","clearInterval","clearReactNativeMicrotask","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callReactNativeMicrotasks","emitTimeDriftWarning","warningMessage","callbackID","jsSchedulingTime","repeats","sendIdleEvents","ExportedJSTimers","setReactNativeMicrotasksCallback","module","exports"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\nimport NativeTiming from './NativeTiming';\n\nconst BatchedBridge = require('../../BatchedBridge/BatchedBridge');\nconst Systrace = require('../../Performance/Systrace');\nconst invariant = require('invariant');\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\nexport type JSTimerType =\n  | 'setTimeout'\n  | 'setInterval'\n  | 'requestAnimationFrame'\n  | 'queueReactNativeMicrotask'\n  | 'requestIdleCallback';\n\n// These timing constants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\n// Parallel arrays\nconst callbacks: Array<?Function> = [];\nconst types: Array<?JSTimerType> = [];\nconst timerIDs: Array<?number> = [];\nlet reactNativeMicrotasks: Array<number> = [];\nlet requestIdleCallbacks: Array<number> = [];\nconst requestIdleCallbackTimeouts: {[number]: number, ...} = {};\n\nlet GUID = 1;\nconst errors: Array<Error> = [];\n\nlet hasEmittedTimeDriftWarning = false;\n\n// Returns a free index if one is available, and the next consecutive index otherwise.\nfunction _getFreeIndex(): number {\n  let freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\n\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\n  const id = GUID++;\n  const freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  return id;\n}\n\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n  if (timerID > GUID) {\n    console.warn(\n      'Tried to call timer with ID %s but no such timer exists.',\n      timerID,\n    );\n  }\n\n  // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n  const timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n\n  const type = types[timerIndex];\n  const callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent(type + ' [invoke]');\n  }\n\n  // Clear the metadata\n  if (type !== 'setInterval') {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (\n      type === 'setTimeout' ||\n      type === 'setInterval' ||\n      type === 'queueReactNativeMicrotask'\n    ) {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(global.performance.now());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function () {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(\n            0,\n            FRAME_DURATION - (global.performance.now() - frameTime),\n          );\n        },\n        didTimeout: !!didTimeout,\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    errors.push(e);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\n/**\n * Performs a single pass over the enqueued reactNativeMicrotasks. Returns whether\n * more reactNativeMicrotasks are queued up (can be used as a condition a while loop).\n */\nfunction _callReactNativeMicrotasksPass() {\n  if (reactNativeMicrotasks.length === 0) {\n    return false;\n  }\n\n  if (__DEV__) {\n    Systrace.beginEvent('callReactNativeMicrotasksPass()');\n  }\n\n  // The main reason to extract a single pass is so that we can track\n  // in the system trace\n  const passReactNativeMicrotasks = reactNativeMicrotasks;\n  reactNativeMicrotasks = [];\n\n  // Use for loop rather than forEach as per @vjeux's advice\n  // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n  for (let i = 0; i < passReactNativeMicrotasks.length; ++i) {\n    _callTimer(passReactNativeMicrotasks[i], 0);\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return reactNativeMicrotasks.length > 0;\n}\n\nfunction _clearIndex(i: number) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n}\n\nfunction _freeCallback(timerID: number) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  const index = timerIDs.indexOf(timerID);\n  // See corresponding comment in `callTimers` for reasoning behind this\n  if (index !== -1) {\n    const type = types[index];\n    _clearIndex(index);\n    if (\n      type !== 'queueReactNativeMicrotask' &&\n      type !== 'requestIdleCallback'\n    ) {\n      deleteTimer(timerID);\n    }\n  }\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function (\n    func: Function,\n    duration: number,\n    ...args: any\n  ): number {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setTimeout',\n    );\n    createTimer(id, duration || 0, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function (\n    func: Function,\n    duration: number,\n    ...args: any\n  ): number {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setInterval',\n    );\n    createTimer(id, duration || 0, Date.now(), /* recurring */ true);\n    return id;\n  },\n\n  /**\n   * The React Native microtask mechanism is used to back public APIs e.g.\n   * `queueMicrotask`, `clearImmediate`, and `setImmediate` (which is used by\n   * the Promise polyfill) when the JSVM microtask mechanism is not used.\n   *\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n  queueReactNativeMicrotask: function (func: Function, ...args: any): number {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'queueReactNativeMicrotask',\n    );\n    reactNativeMicrotasks.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n  requestAnimationFrame: function (func: Function): any | number {\n    const id = _allocateCallback(func, 'requestAnimationFrame');\n    createTimer(id, 1, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n  requestIdleCallback: function (\n    func: Function,\n    options: ?Object,\n  ): any | number {\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(true);\n    }\n\n    const timeout = options && options.timeout;\n    const id: number = _allocateCallback(\n      timeout != null\n        ? (deadline: any) => {\n            const timeoutId: number = requestIdleCallbackTimeouts[id];\n            if (timeoutId) {\n              JSTimers.clearTimeout(timeoutId);\n              delete requestIdleCallbackTimeouts[id];\n            }\n            return func(deadline);\n          }\n        : func,\n      'requestIdleCallback',\n    );\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      const timeoutId: number = JSTimers.setTimeout(() => {\n        const index: number = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, global.performance.now(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n\n  cancelIdleCallback: function (timerID: number) {\n    _freeCallback(timerID);\n    const index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n  },\n\n  clearTimeout: function (timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearInterval: function (timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearReactNativeMicrotask: function (timerID: number) {\n    _freeCallback(timerID);\n    const index = reactNativeMicrotasks.indexOf(timerID);\n    if (index !== -1) {\n      reactNativeMicrotasks.splice(index, 1);\n    }\n  },\n\n  cancelAnimationFrame: function (timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function (timersToCall: Array<number>): any | void {\n    invariant(\n      timersToCall.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.',\n    );\n\n    errors.length = 0;\n    for (let i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    const errorCount = errors.length;\n    if (errorCount > 0) {\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(\n            ((error: Error) => {\n              throw error;\n            }).bind(null, errors[ii]),\n            0,\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function (frameTime: number) {\n    if (\n      FRAME_DURATION - (global.performance.now() - frameTime) <\n      IDLE_CALLBACK_FRAME_DEADLINE\n    ) {\n      return;\n    }\n\n    errors.length = 0;\n    if (requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = requestIdleCallbacks;\n      requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      setSendIdleEvents(false);\n    }\n\n    errors.forEach(error =>\n      JSTimers.setTimeout(() => {\n        throw error;\n      }, 0),\n    );\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callReactNativeMicrotasks() {\n    errors.length = 0;\n    while (_callReactNativeMicrotasksPass()) {}\n    errors.forEach(error =>\n      JSTimers.setTimeout(() => {\n        throw error;\n      }, 0),\n    );\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n};\n\nfunction createTimer(\n  callbackID: number,\n  duration: number,\n  jsSchedulingTime: number,\n  repeats: boolean,\n): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.createTimer(callbackID, duration, jsSchedulingTime, repeats);\n}\n\nfunction deleteTimer(timerID: number): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.deleteTimer(timerID);\n}\n\nfunction setSendIdleEvents(sendIdleEvents: boolean): void {\n  invariant(NativeTiming, 'NativeTiming is available');\n  NativeTiming.setSendIdleEvents(sendIdleEvents);\n}\n\nlet ExportedJSTimers: {|\n  callIdleCallbacks: (frameTime: number) => any | void,\n  callReactNativeMicrotasks: () => void,\n  callTimers: (timersToCall: Array<number>) => any | void,\n  cancelAnimationFrame: (timerID: number) => void,\n  cancelIdleCallback: (timerID: number) => void,\n  clearReactNativeMicrotask: (timerID: number) => void,\n  clearInterval: (timerID: number) => void,\n  clearTimeout: (timerID: number) => void,\n  emitTimeDriftWarning: (warningMessage: string) => any | void,\n  requestAnimationFrame: (func: any) => any | number,\n  requestIdleCallback: (func: any, options: ?any) => any | number,\n  queueReactNativeMicrotask: (func: any, ...args: any) => number,\n  setInterval: (func: any, duration: number, ...args: any) => number,\n  setTimeout: (func: any, duration: number, ...args: any) => number,\n|};\n\nif (!NativeTiming) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  // $FlowFixMe[prop-missing] : we can assume timers are generally available\n  ExportedJSTimers = ({\n    callReactNativeMicrotasks: JSTimers.callReactNativeMicrotasks,\n    queueReactNativeMicrotask: JSTimers.queueReactNativeMicrotask,\n  }: typeof JSTimers);\n} else {\n  ExportedJSTimers = JSTimers;\n}\n\nBatchedBridge.setReactNativeMicrotasksCallback(\n  JSTimers.callReactNativeMicrotasks,\n);\n\nmodule.exports = ExportedJSTimers;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}