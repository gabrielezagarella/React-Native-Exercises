{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StatusBar from \"react-native-web/dist/exports/StatusBar\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { PanGestureHandler, State as GestureState } from 'react-native-gesture-handler';\nimport Animated, { interpolate, runOnJS, useAnimatedGestureHandler, useAnimatedStyle, useDerivedValue, useSharedValue, withSpring } from 'react-native-reanimated';\nimport DrawerProgressContext from \"../../utils/DrawerProgressContext\";\nimport Overlay from \"./Overlay\";\nvar SWIPE_DISTANCE_MINIMUM = 5;\nvar DEFAULT_DRAWER_WIDTH = '80%';\n\nvar minmax = function minmax(value, start, end) {\n  'worklet';\n\n  return Math.min(Math.max(value, start), end);\n};\n\nexport default function Drawer(_ref) {\n  var dimensions = _ref.dimensions,\n      drawerPosition = _ref.drawerPosition,\n      drawerStyle = _ref.drawerStyle,\n      drawerType = _ref.drawerType,\n      gestureHandlerProps = _ref.gestureHandlerProps,\n      hideStatusBarOnOpen = _ref.hideStatusBarOnOpen,\n      keyboardDismissMode = _ref.keyboardDismissMode,\n      onClose = _ref.onClose,\n      onOpen = _ref.onOpen,\n      open = _ref.open,\n      overlayStyle = _ref.overlayStyle,\n      renderDrawerContent = _ref.renderDrawerContent,\n      renderSceneContent = _ref.renderSceneContent,\n      statusBarAnimation = _ref.statusBarAnimation,\n      swipeDistanceThreshold = _ref.swipeDistanceThreshold,\n      swipeEdgeWidth = _ref.swipeEdgeWidth,\n      swipeEnabled = _ref.swipeEnabled,\n      swipeVelocityThreshold = _ref.swipeVelocityThreshold,\n      overlayAccessibilityLabel = _ref.overlayAccessibilityLabel;\n\n  var getDrawerWidth = function getDrawerWidth() {\n    var _ref3 = StyleSheet.flatten(drawerStyle) || {},\n        _ref3$width = _ref3.width,\n        width = _ref3$width === void 0 ? DEFAULT_DRAWER_WIDTH : _ref3$width;\n\n    if (typeof width === 'string' && width.endsWith('%')) {\n      var percentage = Number(width.replace(/%$/, ''));\n\n      if (Number.isFinite(percentage)) {\n        return dimensions.width * (percentage / 100);\n      }\n    }\n\n    return typeof width === 'number' ? width : 0;\n  };\n\n  var drawerWidth = getDrawerWidth();\n  var isOpen = drawerType === 'permanent' ? true : open;\n  var isRight = drawerPosition === 'right';\n  var getDrawerTranslationX = React.useCallback(function (open) {\n    'worklet';\n\n    if (drawerPosition === 'left') {\n      return open ? 0 : -drawerWidth;\n    }\n\n    return open ? 0 : drawerWidth;\n  }, [drawerPosition, drawerWidth]);\n  var hideStatusBar = React.useCallback(function (hide) {\n    if (hideStatusBarOnOpen) {\n      StatusBar.setHidden(hide, statusBarAnimation);\n    }\n  }, [hideStatusBarOnOpen, statusBarAnimation]);\n  React.useEffect(function () {\n    hideStatusBar(isOpen);\n    return function () {\n      return hideStatusBar(false);\n    };\n  }, [isOpen, hideStatusBarOnOpen, statusBarAnimation, hideStatusBar]);\n  var interactionHandleRef = React.useRef(null);\n\n  var startInteraction = function startInteraction() {\n    interactionHandleRef.current = InteractionManager.createInteractionHandle();\n  };\n\n  var endInteraction = function endInteraction() {\n    if (interactionHandleRef.current != null) {\n      InteractionManager.clearInteractionHandle(interactionHandleRef.current);\n      interactionHandleRef.current = null;\n    }\n  };\n\n  var hideKeyboard = function hideKeyboard() {\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n  };\n\n  var onGestureStart = function onGestureStart() {\n    startInteraction();\n    hideKeyboard();\n    hideStatusBar(true);\n  };\n\n  var onGestureFinish = function onGestureFinish() {\n    endInteraction();\n  };\n\n  var hitSlop = isRight ? {\n    right: 0,\n    width: isOpen ? undefined : swipeEdgeWidth\n  } : {\n    left: 0,\n    width: isOpen ? undefined : swipeEdgeWidth\n  };\n  var touchStartX = useSharedValue(0);\n  var touchX = useSharedValue(0);\n  var translationX = useSharedValue(getDrawerTranslationX(open));\n  var gestureState = useSharedValue(GestureState.UNDETERMINED);\n  var toggleDrawer = React.useCallback(function (_ref2) {\n    'worklet';\n\n    var open = _ref2.open,\n        isUserInitiated = _ref2.isUserInitiated,\n        velocity = _ref2.velocity;\n    var translateX = getDrawerTranslationX(open);\n    touchStartX.value = 0;\n    touchX.value = 0;\n    translationX.value = withSpring(translateX, {\n      velocity: velocity,\n      stiffness: 1000,\n      damping: 500,\n      mass: 3,\n      overshootClamping: true,\n      restDisplacementThreshold: 0.01,\n      restSpeedThreshold: 0.01\n    });\n\n    if (!isUserInitiated) {\n      return;\n    }\n\n    if (open) {\n      runOnJS(onOpen)();\n    } else {\n      runOnJS(onClose)();\n    }\n  }, [getDrawerTranslationX, onClose, onOpen, touchStartX, touchX, translationX]);\n  React.useEffect(function () {\n    return toggleDrawer({\n      open: open,\n      isUserInitiated: false\n    });\n  }, [open, toggleDrawer]);\n  var onGestureEvent = useAnimatedGestureHandler({\n    onStart: function onStart(event, ctx) {\n      ctx.hasCalledOnStart = false;\n      ctx.startX = translationX.value;\n      gestureState.value = event.state;\n      touchStartX.value = event.x;\n    },\n    onActive: function onActive(event, ctx) {\n      touchX.value = event.x;\n      translationX.value = ctx.startX + event.translationX;\n      gestureState.value = event.state;\n\n      if (!ctx.hasCalledOnStart) {\n        ctx.hasCalledOnStart = true;\n        runOnJS(onGestureStart)();\n      }\n    },\n    onEnd: function onEnd(event) {\n      gestureState.value = event.state;\n      var nextOpen = Math.abs(event.translationX) > SWIPE_DISTANCE_MINIMUM && Math.abs(event.translationX) > swipeVelocityThreshold || Math.abs(event.translationX) > swipeDistanceThreshold ? drawerPosition === 'left' ? (event.velocityX === 0 ? event.translationX : event.velocityX) > 0 : (event.velocityX === 0 ? event.translationX : event.velocityX) < 0 : open;\n      toggleDrawer({\n        open: nextOpen,\n        isUserInitiated: true,\n        velocity: event.velocityX\n      });\n    },\n    onFinish: function onFinish() {\n      runOnJS(onGestureFinish)();\n    }\n  });\n  var translateX = useDerivedValue(function () {\n    var touchDistance = drawerType === 'front' && gestureState.value === GestureState.ACTIVE ? minmax(drawerPosition === 'left' ? touchStartX.value - drawerWidth : dimensions.width - drawerWidth - touchStartX.value, 0, dimensions.width) : 0;\n    var translateX = drawerPosition === 'left' ? minmax(translationX.value + touchDistance, -drawerWidth, 0) : minmax(translationX.value - touchDistance, 0, drawerWidth);\n    return translateX;\n  });\n  var isRTL = I18nManager.getConstants().isRTL;\n  var drawerAnimatedStyle = useAnimatedStyle(function () {\n    var distanceFromEdge = dimensions.width - drawerWidth;\n    return {\n      transform: drawerType === 'permanent' ? [] : [{\n        translateX: (drawerType === 'back' ? 0 : translateX.value) + (drawerPosition === 'left' ? isRTL ? -distanceFromEdge : 0 : isRTL ? 0 : distanceFromEdge)\n      }]\n    };\n  });\n  var contentAnimatedStyle = useAnimatedStyle(function () {\n    return {\n      transform: drawerType === 'permanent' ? [] : [{\n        translateX: drawerType === 'front' ? 0 : translateX.value + drawerWidth * (drawerPosition === 'left' ? 1 : -1)\n      }]\n    };\n  });\n  var progress = useDerivedValue(function () {\n    return drawerType === 'permanent' ? 1 : interpolate(translateX.value, [getDrawerTranslationX(false), getDrawerTranslationX(true)], [0, 1]);\n  });\n  return React.createElement(DrawerProgressContext.Provider, {\n    value: progress\n  }, React.createElement(PanGestureHandler, _extends({\n    activeOffsetX: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n    failOffsetY: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n    hitSlop: hitSlop,\n    enabled: drawerType !== 'permanent' && swipeEnabled,\n    onGestureEvent: onGestureEvent\n  }, gestureHandlerProps), React.createElement(Animated.View, {\n    style: [styles.main, {\n      flexDirection: drawerType === 'permanent' && !isRight ? 'row-reverse' : 'row'\n    }]\n  }, React.createElement(Animated.View, {\n    style: [styles.content, contentAnimatedStyle]\n  }, React.createElement(View, {\n    accessibilityElementsHidden: isOpen && drawerType !== 'permanent',\n    importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',\n    style: styles.content\n  }, renderSceneContent()), drawerType !== 'permanent' ? React.createElement(Overlay, {\n    progress: progress,\n    onPress: function onPress() {\n      return toggleDrawer({\n        open: false,\n        isUserInitiated: true\n      });\n    },\n    style: overlayStyle,\n    accessibilityLabel: overlayAccessibilityLabel\n  }) : null), React.createElement(Animated.View, {\n    removeClippedSubviews: Platform.OS !== 'ios',\n    style: [styles.container, {\n      position: drawerType === 'permanent' ? 'relative' : 'absolute',\n      zIndex: drawerType === 'back' ? -1 : 0\n    }, drawerAnimatedStyle, drawerStyle]\n  }, renderDrawerContent()))));\n}\nvar styles = StyleSheet.create({\n  container: {\n    top: 0,\n    bottom: 0,\n    maxWidth: '100%',\n    width: DEFAULT_DRAWER_WIDTH\n  },\n  content: {\n    flex: 1\n  },\n  main: _objectSpread({\n    flex: 1\n  }, Platform.select({\n    web: null,\n    default: {\n      overflow: 'hidden'\n    }\n  }))\n});","map":{"version":3,"sources":["views/modern/Drawer.tsx"],"names":["React","PanGestureHandler","State","GestureState","Animated","interpolate","runOnJS","useAnimatedGestureHandler","useAnimatedStyle","useDerivedValue","useSharedValue","withSpring","DrawerProgressContext","Overlay","SWIPE_DISTANCE_MINIMUM","DEFAULT_DRAWER_WIDTH","minmax","value","start","end","Math","min","max","Drawer","dimensions","drawerPosition","drawerStyle","drawerType","gestureHandlerProps","hideStatusBarOnOpen","keyboardDismissMode","onClose","onOpen","open","overlayStyle","renderDrawerContent","renderSceneContent","statusBarAnimation","swipeDistanceThreshold","swipeEdgeWidth","swipeEnabled","swipeVelocityThreshold","overlayAccessibilityLabel","getDrawerWidth","width","StyleSheet","flatten","endsWith","percentage","Number","replace","isFinite","drawerWidth","isOpen","isRight","getDrawerTranslationX","useCallback","hideStatusBar","hide","StatusBar","setHidden","useEffect","interactionHandleRef","useRef","startInteraction","current","InteractionManager","createInteractionHandle","endInteraction","clearInteractionHandle","hideKeyboard","Keyboard","dismiss","onGestureStart","onGestureFinish","hitSlop","right","undefined","left","touchStartX","touchX","translationX","gestureState","UNDETERMINED","toggleDrawer","isUserInitiated","velocity","translateX","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","onGestureEvent","onStart","event","ctx","hasCalledOnStart","startX","state","x","onActive","onEnd","nextOpen","abs","velocityX","onFinish","touchDistance","ACTIVE","isRTL","I18nManager","getConstants","drawerAnimatedStyle","distanceFromEdge","transform","contentAnimatedStyle","progress","styles","main","flexDirection","content","Platform","OS","container","position","zIndex","create","top","bottom","maxWidth","flex","select","web","default","overflow"],"mappings":"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","sourceRoot":"../../../../src","sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as React from 'react';\nimport { I18nManager, InteractionManager, Keyboard, Platform, StatusBar, StyleSheet, View } from 'react-native';\nimport { PanGestureHandler, State as GestureState } from 'react-native-gesture-handler';\nimport Animated, { interpolate, runOnJS, useAnimatedGestureHandler, useAnimatedStyle, useDerivedValue, useSharedValue, withSpring } from 'react-native-reanimated';\nimport DrawerProgressContext from '../../utils/DrawerProgressContext';\nimport Overlay from './Overlay';\nconst SWIPE_DISTANCE_MINIMUM = 5;\nconst DEFAULT_DRAWER_WIDTH = '80%';\nconst minmax = (value, start, end) => {\n  'worklet';\n\n  return Math.min(Math.max(value, start), end);\n};\nexport default function Drawer(_ref) {\n  let {\n    dimensions,\n    drawerPosition,\n    drawerStyle,\n    drawerType,\n    gestureHandlerProps,\n    hideStatusBarOnOpen,\n    keyboardDismissMode,\n    onClose,\n    onOpen,\n    open,\n    overlayStyle,\n    renderDrawerContent,\n    renderSceneContent,\n    statusBarAnimation,\n    swipeDistanceThreshold,\n    swipeEdgeWidth,\n    swipeEnabled,\n    swipeVelocityThreshold,\n    overlayAccessibilityLabel\n  } = _ref;\n  const getDrawerWidth = () => {\n    const {\n      width = DEFAULT_DRAWER_WIDTH\n    } = StyleSheet.flatten(drawerStyle) || {};\n    if (typeof width === 'string' && width.endsWith('%')) {\n      // Try to calculate width if a percentage is given\n      const percentage = Number(width.replace(/%$/, ''));\n      if (Number.isFinite(percentage)) {\n        return dimensions.width * (percentage / 100);\n      }\n    }\n    return typeof width === 'number' ? width : 0;\n  };\n  const drawerWidth = getDrawerWidth();\n  const isOpen = drawerType === 'permanent' ? true : open;\n  const isRight = drawerPosition === 'right';\n  const getDrawerTranslationX = React.useCallback(open => {\n    'worklet';\n\n    if (drawerPosition === 'left') {\n      return open ? 0 : -drawerWidth;\n    }\n    return open ? 0 : drawerWidth;\n  }, [drawerPosition, drawerWidth]);\n  const hideStatusBar = React.useCallback(hide => {\n    if (hideStatusBarOnOpen) {\n      StatusBar.setHidden(hide, statusBarAnimation);\n    }\n  }, [hideStatusBarOnOpen, statusBarAnimation]);\n  React.useEffect(() => {\n    hideStatusBar(isOpen);\n    return () => hideStatusBar(false);\n  }, [isOpen, hideStatusBarOnOpen, statusBarAnimation, hideStatusBar]);\n  const interactionHandleRef = React.useRef(null);\n  const startInteraction = () => {\n    interactionHandleRef.current = InteractionManager.createInteractionHandle();\n  };\n  const endInteraction = () => {\n    if (interactionHandleRef.current != null) {\n      InteractionManager.clearInteractionHandle(interactionHandleRef.current);\n      interactionHandleRef.current = null;\n    }\n  };\n  const hideKeyboard = () => {\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n  };\n  const onGestureStart = () => {\n    startInteraction();\n    hideKeyboard();\n    hideStatusBar(true);\n  };\n  const onGestureFinish = () => {\n    endInteraction();\n  };\n\n  // FIXME: Currently hitSlop is broken when on Android when drawer is on right\n  // https://github.com/software-mansion/react-native-gesture-handler/issues/569\n  const hitSlop = isRight ?\n  // Extend hitSlop to the side of the screen when drawer is closed\n  // This lets the user drag the drawer from the side of the screen\n  {\n    right: 0,\n    width: isOpen ? undefined : swipeEdgeWidth\n  } : {\n    left: 0,\n    width: isOpen ? undefined : swipeEdgeWidth\n  };\n  const touchStartX = useSharedValue(0);\n  const touchX = useSharedValue(0);\n  const translationX = useSharedValue(getDrawerTranslationX(open));\n  const gestureState = useSharedValue(GestureState.UNDETERMINED);\n  const toggleDrawer = React.useCallback(_ref2 => {\n    'worklet';\n\n    let {\n      open,\n      isUserInitiated,\n      velocity\n    } = _ref2;\n    const translateX = getDrawerTranslationX(open);\n    touchStartX.value = 0;\n    touchX.value = 0;\n    translationX.value = withSpring(translateX, {\n      velocity,\n      stiffness: 1000,\n      damping: 500,\n      mass: 3,\n      overshootClamping: true,\n      restDisplacementThreshold: 0.01,\n      restSpeedThreshold: 0.01\n    });\n    if (!isUserInitiated) {\n      return;\n    }\n    if (open) {\n      runOnJS(onOpen)();\n    } else {\n      runOnJS(onClose)();\n    }\n  }, [getDrawerTranslationX, onClose, onOpen, touchStartX, touchX, translationX]);\n  React.useEffect(() => toggleDrawer({\n    open,\n    isUserInitiated: false\n  }), [open, toggleDrawer]);\n  const onGestureEvent = useAnimatedGestureHandler({\n    onStart: (event, ctx) => {\n      ctx.hasCalledOnStart = false;\n      ctx.startX = translationX.value;\n      gestureState.value = event.state;\n      touchStartX.value = event.x;\n    },\n    onActive: (event, ctx) => {\n      touchX.value = event.x;\n      translationX.value = ctx.startX + event.translationX;\n      gestureState.value = event.state;\n\n      // onStart will _always_ be called, even when the activation\n      // criteria isn't met yet. This makes sure onGestureStart is only\n      // called when the criteria is really met.\n      if (!ctx.hasCalledOnStart) {\n        ctx.hasCalledOnStart = true;\n        runOnJS(onGestureStart)();\n      }\n    },\n    onEnd: event => {\n      gestureState.value = event.state;\n      const nextOpen = Math.abs(event.translationX) > SWIPE_DISTANCE_MINIMUM && Math.abs(event.translationX) > swipeVelocityThreshold || Math.abs(event.translationX) > swipeDistanceThreshold ? drawerPosition === 'left' ?\n      // If swiped to right, open the drawer, otherwise close it\n      (event.velocityX === 0 ? event.translationX : event.velocityX) > 0 :\n      // If swiped to left, open the drawer, otherwise close it\n      (event.velocityX === 0 ? event.translationX : event.velocityX) < 0 : open;\n      toggleDrawer({\n        open: nextOpen,\n        isUserInitiated: true,\n        velocity: event.velocityX\n      });\n    },\n    onFinish: () => {\n      runOnJS(onGestureFinish)();\n    }\n  });\n  const translateX = useDerivedValue(() => {\n    // Comment stolen from react-native-gesture-handler/DrawerLayout\n    //\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the translationX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    const touchDistance = drawerType === 'front' && gestureState.value === GestureState.ACTIVE ? minmax(drawerPosition === 'left' ? touchStartX.value - drawerWidth : dimensions.width - drawerWidth - touchStartX.value, 0, dimensions.width) : 0;\n    const translateX = drawerPosition === 'left' ? minmax(translationX.value + touchDistance, -drawerWidth, 0) : minmax(translationX.value - touchDistance, 0, drawerWidth);\n    return translateX;\n  });\n  const isRTL = I18nManager.getConstants().isRTL;\n  const drawerAnimatedStyle = useAnimatedStyle(() => {\n    const distanceFromEdge = dimensions.width - drawerWidth;\n    return {\n      transform: drawerType === 'permanent' ?\n      // Reanimated needs the property to be present, but it results in Browser bug\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=20574\n      [] : [{\n        translateX:\n        // The drawer stays in place when `drawerType` is `back`\n        (drawerType === 'back' ? 0 : translateX.value) + (drawerPosition === 'left' ? isRTL ? -distanceFromEdge : 0 : isRTL ? 0 : distanceFromEdge)\n      }]\n    };\n  });\n  const contentAnimatedStyle = useAnimatedStyle(() => {\n    return {\n      transform: drawerType === 'permanent' ?\n      // Reanimated needs the property to be present, but it results in Browser bug\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=20574\n      [] : [{\n        translateX:\n        // The screen content stays in place when `drawerType` is `front`\n        drawerType === 'front' ? 0 : translateX.value + drawerWidth * (drawerPosition === 'left' ? 1 : -1)\n      }]\n    };\n  });\n  const progress = useDerivedValue(() => {\n    return drawerType === 'permanent' ? 1 : interpolate(translateX.value, [getDrawerTranslationX(false), getDrawerTranslationX(true)], [0, 1]);\n  });\n  return /*#__PURE__*/React.createElement(DrawerProgressContext.Provider, {\n    value: progress\n  }, /*#__PURE__*/React.createElement(PanGestureHandler, _extends({\n    activeOffsetX: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n    failOffsetY: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n    hitSlop: hitSlop,\n    enabled: drawerType !== 'permanent' && swipeEnabled,\n    onGestureEvent: onGestureEvent\n  }, gestureHandlerProps), /*#__PURE__*/React.createElement(Animated.View, {\n    style: [styles.main, {\n      flexDirection: drawerType === 'permanent' && !isRight ? 'row-reverse' : 'row'\n    }]\n  }, /*#__PURE__*/React.createElement(Animated.View, {\n    style: [styles.content, contentAnimatedStyle]\n  }, /*#__PURE__*/React.createElement(View, {\n    accessibilityElementsHidden: isOpen && drawerType !== 'permanent',\n    importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',\n    style: styles.content\n  }, renderSceneContent()), drawerType !== 'permanent' ? /*#__PURE__*/React.createElement(Overlay, {\n    progress: progress,\n    onPress: () => toggleDrawer({\n      open: false,\n      isUserInitiated: true\n    }),\n    style: overlayStyle,\n    accessibilityLabel: overlayAccessibilityLabel\n  }) : null), /*#__PURE__*/React.createElement(Animated.View, {\n    removeClippedSubviews: Platform.OS !== 'ios',\n    style: [styles.container, {\n      position: drawerType === 'permanent' ? 'relative' : 'absolute',\n      zIndex: drawerType === 'back' ? -1 : 0\n    }, drawerAnimatedStyle, drawerStyle]\n  }, renderDrawerContent()))));\n}\nconst styles = StyleSheet.create({\n  container: {\n    top: 0,\n    bottom: 0,\n    maxWidth: '100%',\n    width: DEFAULT_DRAWER_WIDTH\n  },\n  content: {\n    flex: 1\n  },\n  main: {\n    flex: 1,\n    ...Platform.select({\n      // FIXME: We need to hide `overflowX` on Web so the translated content doesn't show offscreen.\n      // But adding `overflowX: 'hidden'` prevents content from collapsing the URL bar.\n      web: null,\n      default: {\n        overflow: 'hidden'\n      }\n    })\n  }\n});\n//# sourceMappingURL=Drawer.js.map"]},"metadata":{},"sourceType":"module"}