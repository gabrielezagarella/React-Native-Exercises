{"ast":null,"code":"import invariant from 'invariant';\n\nvar NativeModules = require(\"../BatchedBridge/NativeModules\");\n\nvar turboModuleProxy = global.__turboModuleProxy;\n\nfunction requireModule(name) {\n  if (global.RN$Bridgeless !== true) {\n    var legacyModule = NativeModules[name];\n\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n\n  if (turboModuleProxy != null) {\n    var module = turboModuleProxy(name);\n    return module;\n  }\n\n  return null;\n}\n\nexport function get(name) {\n  return requireModule(name);\n}\nexport function getEnforcing(name) {\n  var module = requireModule(name);\n  invariant(module != null, \"TurboModuleRegistry.getEnforcing(...): '\" + name + \"' could not be found. \" + 'Verify that a module by this name is registered in the native binary.');\n  return module;\n}","map":{"version":3,"names":["invariant","NativeModules","require","turboModuleProxy","global","__turboModuleProxy","requireModule","name","RN$Bridgeless","legacyModule","module","get","getEnforcing"],"sources":["/Users/zagarellagabriele/Desktop/Progetti/React Native/React-Native-Exercises/node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {TurboModule} from './RCTExport';\n\nimport invariant from 'invariant';\n\nconst NativeModules = require('../BatchedBridge/NativeModules');\n\nconst turboModuleProxy = global.__turboModuleProxy;\n\nfunction requireModule<T: TurboModule>(name: string): ?T {\n  // Bridgeless mode requires TurboModules\n  if (global.RN$Bridgeless !== true) {\n    // Backward compatibility layer during migration.\n    const legacyModule = NativeModules[name];\n    if (legacyModule != null) {\n      return ((legacyModule: $FlowFixMe): T);\n    }\n  }\n\n  if (turboModuleProxy != null) {\n    const module: ?T = turboModuleProxy(name);\n    return module;\n  }\n\n  return null;\n}\n\nexport function get<T: TurboModule>(name: string): ?T {\n  return requireModule<T>(name);\n}\n\nexport function getEnforcing<T: TurboModule>(name: string): T {\n  const module = requireModule<T>(name);\n  invariant(\n    module != null,\n    `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` +\n      'Verify that a module by this name is registered in the native binary.',\n  );\n  return module;\n}\n"],"mappings":"AAYA,OAAOA,SAAP,MAAsB,WAAtB;;AAEA,IAAMC,aAAa,GAAGC,OAAO,kCAA7B;;AAEA,IAAMC,gBAAgB,GAAGC,MAAM,CAACC,kBAAhC;;AAEA,SAASC,aAAT,CAAuCC,IAAvC,EAAyD;EAEvD,IAAIH,MAAM,CAACI,aAAP,KAAyB,IAA7B,EAAmC;IAEjC,IAAMC,YAAY,GAAGR,aAAa,CAACM,IAAD,CAAlC;;IACA,IAAIE,YAAY,IAAI,IAApB,EAA0B;MACxB,OAASA,YAAT;IACD;EACF;;EAED,IAAIN,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,IAAMO,MAAU,GAAGP,gBAAgB,CAACI,IAAD,CAAnC;IACA,OAAOG,MAAP;EACD;;EAED,OAAO,IAAP;AACD;;AAED,OAAO,SAASC,GAAT,CAA6BJ,IAA7B,EAA+C;EACpD,OAAOD,aAAa,CAAIC,IAAJ,CAApB;AACD;AAED,OAAO,SAASK,YAAT,CAAsCL,IAAtC,EAAuD;EAC5D,IAAMG,MAAM,GAAGJ,aAAa,CAAIC,IAAJ,CAA5B;EACAP,SAAS,CACPU,MAAM,IAAI,IADH,EAEP,6CAA2CH,IAA3C,8BACE,uEAHK,CAAT;EAKA,OAAOG,MAAP;AACD"},"metadata":{},"sourceType":"module"}